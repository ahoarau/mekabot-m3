// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: humanoid.proto

#ifndef PROTOBUF_humanoid_2eproto__INCLUDED
#define PROTOBUF_humanoid_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "component_base.pb.h"
#include "joint_array_mode.pb.h"
#include "trajectory.pb.h"
#include "smoothing_mode.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_humanoid_2eproto();
void protobuf_AssignDesc_humanoid_2eproto();
void protobuf_ShutdownFile_humanoid_2eproto();

class M3HumanoidStatus;
class M3HumanoidCommand;
class M3HumanoidParam;
class M3BaseHumanoidStatus;
class M3BaseHumanoidCommand;
class M3BaseHumanoidParam;

// ===================================================================

class M3HumanoidStatus : public ::google::protobuf::Message {
 public:
  M3HumanoidStatus();
  virtual ~M3HumanoidStatus();

  M3HumanoidStatus(const M3HumanoidStatus& from);

  inline M3HumanoidStatus& operator=(const M3HumanoidStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3HumanoidStatus& default_instance();

  void Swap(M3HumanoidStatus* other);

  // implements Message ----------------------------------------------

  M3HumanoidStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3HumanoidStatus& from);
  void MergeFrom(const M3HumanoidStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .M3BaseStatus base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::M3BaseStatus& base() const;
  inline ::M3BaseStatus* mutable_base();
  inline ::M3BaseStatus* release_base();
  inline void set_allocated_base(::M3BaseStatus* base);

  // optional .M3BaseHumanoidStatus right_arm = 2;
  inline bool has_right_arm() const;
  inline void clear_right_arm();
  static const int kRightArmFieldNumber = 2;
  inline const ::M3BaseHumanoidStatus& right_arm() const;
  inline ::M3BaseHumanoidStatus* mutable_right_arm();
  inline ::M3BaseHumanoidStatus* release_right_arm();
  inline void set_allocated_right_arm(::M3BaseHumanoidStatus* right_arm);

  // optional .M3BaseHumanoidStatus left_arm = 3;
  inline bool has_left_arm() const;
  inline void clear_left_arm();
  static const int kLeftArmFieldNumber = 3;
  inline const ::M3BaseHumanoidStatus& left_arm() const;
  inline ::M3BaseHumanoidStatus* mutable_left_arm();
  inline ::M3BaseHumanoidStatus* release_left_arm();
  inline void set_allocated_left_arm(::M3BaseHumanoidStatus* left_arm);

  // optional .M3BaseHumanoidStatus torso = 4;
  inline bool has_torso() const;
  inline void clear_torso();
  static const int kTorsoFieldNumber = 4;
  inline const ::M3BaseHumanoidStatus& torso() const;
  inline ::M3BaseHumanoidStatus* mutable_torso();
  inline ::M3BaseHumanoidStatus* release_torso();
  inline void set_allocated_torso(::M3BaseHumanoidStatus* torso);

  // optional .M3BaseHumanoidStatus head = 5;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 5;
  inline const ::M3BaseHumanoidStatus& head() const;
  inline ::M3BaseHumanoidStatus* mutable_head();
  inline ::M3BaseHumanoidStatus* release_head();
  inline void set_allocated_head(::M3BaseHumanoidStatus* head);

  // optional .M3BaseHumanoidStatus right_hand = 6;
  inline bool has_right_hand() const;
  inline void clear_right_hand();
  static const int kRightHandFieldNumber = 6;
  inline const ::M3BaseHumanoidStatus& right_hand() const;
  inline ::M3BaseHumanoidStatus* mutable_right_hand();
  inline ::M3BaseHumanoidStatus* release_right_hand();
  inline void set_allocated_right_hand(::M3BaseHumanoidStatus* right_hand);

  // optional .M3BaseHumanoidStatus left_hand = 7;
  inline bool has_left_hand() const;
  inline void clear_left_hand();
  static const int kLeftHandFieldNumber = 7;
  inline const ::M3BaseHumanoidStatus& left_hand() const;
  inline ::M3BaseHumanoidStatus* mutable_left_hand();
  inline ::M3BaseHumanoidStatus* release_left_hand();
  inline void set_allocated_left_hand(::M3BaseHumanoidStatus* left_hand);

  // repeated double right_eye_rot = 8;
  inline int right_eye_rot_size() const;
  inline void clear_right_eye_rot();
  static const int kRightEyeRotFieldNumber = 8;
  inline double right_eye_rot(int index) const;
  inline void set_right_eye_rot(int index, double value);
  inline void add_right_eye_rot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      right_eye_rot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_right_eye_rot();

  // repeated double left_eye_rot = 9;
  inline int left_eye_rot_size() const;
  inline void clear_left_eye_rot();
  static const int kLeftEyeRotFieldNumber = 9;
  inline double left_eye_rot(int index) const;
  inline void set_left_eye_rot(int index, double value);
  inline void add_left_eye_rot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      left_eye_rot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_left_eye_rot();

  // repeated double right_eye_pos = 10;
  inline int right_eye_pos_size() const;
  inline void clear_right_eye_pos();
  static const int kRightEyePosFieldNumber = 10;
  inline double right_eye_pos(int index) const;
  inline void set_right_eye_pos(int index, double value);
  inline void add_right_eye_pos(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      right_eye_pos() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_right_eye_pos();

  // repeated double left_eye_pos = 11;
  inline int left_eye_pos_size() const;
  inline void clear_left_eye_pos();
  static const int kLeftEyePosFieldNumber = 11;
  inline double left_eye_pos(int index) const;
  inline void set_left_eye_pos(int index, double value);
  inline void add_left_eye_pos(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      left_eye_pos() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_left_eye_pos();

  // optional bool motor_enabled = 12;
  inline bool has_motor_enabled() const;
  inline void clear_motor_enabled();
  static const int kMotorEnabledFieldNumber = 12;
  inline bool motor_enabled() const;
  inline void set_motor_enabled(bool value);

  // @@protoc_insertion_point(class_scope:M3HumanoidStatus)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_right_arm();
  inline void clear_has_right_arm();
  inline void set_has_left_arm();
  inline void clear_has_left_arm();
  inline void set_has_torso();
  inline void clear_has_torso();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_right_hand();
  inline void clear_has_right_hand();
  inline void set_has_left_hand();
  inline void clear_has_left_hand();
  inline void set_has_motor_enabled();
  inline void clear_has_motor_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::M3BaseStatus* base_;
  ::M3BaseHumanoidStatus* right_arm_;
  ::M3BaseHumanoidStatus* left_arm_;
  ::M3BaseHumanoidStatus* torso_;
  ::M3BaseHumanoidStatus* head_;
  ::M3BaseHumanoidStatus* right_hand_;
  ::M3BaseHumanoidStatus* left_hand_;
  ::google::protobuf::RepeatedField< double > right_eye_rot_;
  ::google::protobuf::RepeatedField< double > left_eye_rot_;
  ::google::protobuf::RepeatedField< double > right_eye_pos_;
  ::google::protobuf::RepeatedField< double > left_eye_pos_;
  bool motor_enabled_;
  friend void  protobuf_AddDesc_humanoid_2eproto();
  friend void protobuf_AssignDesc_humanoid_2eproto();
  friend void protobuf_ShutdownFile_humanoid_2eproto();

  void InitAsDefaultInstance();
  static M3HumanoidStatus* default_instance_;
};
// -------------------------------------------------------------------

class M3HumanoidCommand : public ::google::protobuf::Message {
 public:
  M3HumanoidCommand();
  virtual ~M3HumanoidCommand();

  M3HumanoidCommand(const M3HumanoidCommand& from);

  inline M3HumanoidCommand& operator=(const M3HumanoidCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3HumanoidCommand& default_instance();

  void Swap(M3HumanoidCommand* other);

  // implements Message ----------------------------------------------

  M3HumanoidCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3HumanoidCommand& from);
  void MergeFrom(const M3HumanoidCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .M3BaseHumanoidCommand right_arm = 1;
  inline bool has_right_arm() const;
  inline void clear_right_arm();
  static const int kRightArmFieldNumber = 1;
  inline const ::M3BaseHumanoidCommand& right_arm() const;
  inline ::M3BaseHumanoidCommand* mutable_right_arm();
  inline ::M3BaseHumanoidCommand* release_right_arm();
  inline void set_allocated_right_arm(::M3BaseHumanoidCommand* right_arm);

  // optional .M3BaseHumanoidCommand left_arm = 2;
  inline bool has_left_arm() const;
  inline void clear_left_arm();
  static const int kLeftArmFieldNumber = 2;
  inline const ::M3BaseHumanoidCommand& left_arm() const;
  inline ::M3BaseHumanoidCommand* mutable_left_arm();
  inline ::M3BaseHumanoidCommand* release_left_arm();
  inline void set_allocated_left_arm(::M3BaseHumanoidCommand* left_arm);

  // optional .M3BaseHumanoidCommand torso = 3;
  inline bool has_torso() const;
  inline void clear_torso();
  static const int kTorsoFieldNumber = 3;
  inline const ::M3BaseHumanoidCommand& torso() const;
  inline ::M3BaseHumanoidCommand* mutable_torso();
  inline ::M3BaseHumanoidCommand* release_torso();
  inline void set_allocated_torso(::M3BaseHumanoidCommand* torso);

  // optional .M3BaseHumanoidCommand head = 4;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 4;
  inline const ::M3BaseHumanoidCommand& head() const;
  inline ::M3BaseHumanoidCommand* mutable_head();
  inline ::M3BaseHumanoidCommand* release_head();
  inline void set_allocated_head(::M3BaseHumanoidCommand* head);

  // optional .M3BaseHumanoidCommand right_hand = 5;
  inline bool has_right_hand() const;
  inline void clear_right_hand();
  static const int kRightHandFieldNumber = 5;
  inline const ::M3BaseHumanoidCommand& right_hand() const;
  inline ::M3BaseHumanoidCommand* mutable_right_hand();
  inline ::M3BaseHumanoidCommand* release_right_hand();
  inline void set_allocated_right_hand(::M3BaseHumanoidCommand* right_hand);

  // optional .M3BaseHumanoidCommand left_hand = 6;
  inline bool has_left_hand() const;
  inline void clear_left_hand();
  static const int kLeftHandFieldNumber = 6;
  inline const ::M3BaseHumanoidCommand& left_hand() const;
  inline ::M3BaseHumanoidCommand* mutable_left_hand();
  inline ::M3BaseHumanoidCommand* release_left_hand();
  inline void set_allocated_left_hand(::M3BaseHumanoidCommand* left_hand);

  // optional bool enable_motor = 7;
  inline bool has_enable_motor() const;
  inline void clear_enable_motor();
  static const int kEnableMotorFieldNumber = 7;
  inline bool enable_motor() const;
  inline void set_enable_motor(bool value);

  // @@protoc_insertion_point(class_scope:M3HumanoidCommand)
 private:
  inline void set_has_right_arm();
  inline void clear_has_right_arm();
  inline void set_has_left_arm();
  inline void clear_has_left_arm();
  inline void set_has_torso();
  inline void clear_has_torso();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_right_hand();
  inline void clear_has_right_hand();
  inline void set_has_left_hand();
  inline void clear_has_left_hand();
  inline void set_has_enable_motor();
  inline void clear_has_enable_motor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::M3BaseHumanoidCommand* right_arm_;
  ::M3BaseHumanoidCommand* left_arm_;
  ::M3BaseHumanoidCommand* torso_;
  ::M3BaseHumanoidCommand* head_;
  ::M3BaseHumanoidCommand* right_hand_;
  ::M3BaseHumanoidCommand* left_hand_;
  bool enable_motor_;
  friend void  protobuf_AddDesc_humanoid_2eproto();
  friend void protobuf_AssignDesc_humanoid_2eproto();
  friend void protobuf_ShutdownFile_humanoid_2eproto();

  void InitAsDefaultInstance();
  static M3HumanoidCommand* default_instance_;
};
// -------------------------------------------------------------------

class M3HumanoidParam : public ::google::protobuf::Message {
 public:
  M3HumanoidParam();
  virtual ~M3HumanoidParam();

  M3HumanoidParam(const M3HumanoidParam& from);

  inline M3HumanoidParam& operator=(const M3HumanoidParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3HumanoidParam& default_instance();

  void Swap(M3HumanoidParam* other);

  // implements Message ----------------------------------------------

  M3HumanoidParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3HumanoidParam& from);
  void MergeFrom(const M3HumanoidParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .M3BaseHumanoidParam right_arm = 1;
  inline bool has_right_arm() const;
  inline void clear_right_arm();
  static const int kRightArmFieldNumber = 1;
  inline const ::M3BaseHumanoidParam& right_arm() const;
  inline ::M3BaseHumanoidParam* mutable_right_arm();
  inline ::M3BaseHumanoidParam* release_right_arm();
  inline void set_allocated_right_arm(::M3BaseHumanoidParam* right_arm);

  // optional .M3BaseHumanoidParam left_arm = 2;
  inline bool has_left_arm() const;
  inline void clear_left_arm();
  static const int kLeftArmFieldNumber = 2;
  inline const ::M3BaseHumanoidParam& left_arm() const;
  inline ::M3BaseHumanoidParam* mutable_left_arm();
  inline ::M3BaseHumanoidParam* release_left_arm();
  inline void set_allocated_left_arm(::M3BaseHumanoidParam* left_arm);

  // optional .M3BaseHumanoidParam torso = 3;
  inline bool has_torso() const;
  inline void clear_torso();
  static const int kTorsoFieldNumber = 3;
  inline const ::M3BaseHumanoidParam& torso() const;
  inline ::M3BaseHumanoidParam* mutable_torso();
  inline ::M3BaseHumanoidParam* release_torso();
  inline void set_allocated_torso(::M3BaseHumanoidParam* torso);

  // optional .M3BaseHumanoidParam head = 4;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 4;
  inline const ::M3BaseHumanoidParam& head() const;
  inline ::M3BaseHumanoidParam* mutable_head();
  inline ::M3BaseHumanoidParam* release_head();
  inline void set_allocated_head(::M3BaseHumanoidParam* head);

  // optional .M3BaseHumanoidParam right_hand = 5;
  inline bool has_right_hand() const;
  inline void clear_right_hand();
  static const int kRightHandFieldNumber = 5;
  inline const ::M3BaseHumanoidParam& right_hand() const;
  inline ::M3BaseHumanoidParam* mutable_right_hand();
  inline ::M3BaseHumanoidParam* release_right_hand();
  inline void set_allocated_right_hand(::M3BaseHumanoidParam* right_hand);

  // optional .M3BaseHumanoidParam left_hand = 6;
  inline bool has_left_hand() const;
  inline void clear_left_hand();
  static const int kLeftHandFieldNumber = 6;
  inline const ::M3BaseHumanoidParam& left_hand() const;
  inline ::M3BaseHumanoidParam* mutable_left_hand();
  inline ::M3BaseHumanoidParam* release_left_hand();
  inline void set_allocated_left_hand(::M3BaseHumanoidParam* left_hand);

  // @@protoc_insertion_point(class_scope:M3HumanoidParam)
 private:
  inline void set_has_right_arm();
  inline void clear_has_right_arm();
  inline void set_has_left_arm();
  inline void clear_has_left_arm();
  inline void set_has_torso();
  inline void clear_has_torso();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_right_hand();
  inline void clear_has_right_hand();
  inline void set_has_left_hand();
  inline void clear_has_left_hand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::M3BaseHumanoidParam* right_arm_;
  ::M3BaseHumanoidParam* left_arm_;
  ::M3BaseHumanoidParam* torso_;
  ::M3BaseHumanoidParam* head_;
  ::M3BaseHumanoidParam* right_hand_;
  ::M3BaseHumanoidParam* left_hand_;
  friend void  protobuf_AddDesc_humanoid_2eproto();
  friend void protobuf_AssignDesc_humanoid_2eproto();
  friend void protobuf_ShutdownFile_humanoid_2eproto();

  void InitAsDefaultInstance();
  static M3HumanoidParam* default_instance_;
};
// -------------------------------------------------------------------

class M3BaseHumanoidStatus : public ::google::protobuf::Message {
 public:
  M3BaseHumanoidStatus();
  virtual ~M3BaseHumanoidStatus();

  M3BaseHumanoidStatus(const M3BaseHumanoidStatus& from);

  inline M3BaseHumanoidStatus& operator=(const M3BaseHumanoidStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3BaseHumanoidStatus& default_instance();

  void Swap(M3BaseHumanoidStatus* other);

  // implements Message ----------------------------------------------

  M3BaseHumanoidStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3BaseHumanoidStatus& from);
  void MergeFrom(const M3BaseHumanoidStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double torque = 1;
  inline int torque_size() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 1;
  inline double torque(int index) const;
  inline void set_torque(int index, double value);
  inline void add_torque(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      torque() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_torque();

  // repeated double torquedot = 2;
  inline int torquedot_size() const;
  inline void clear_torquedot();
  static const int kTorquedotFieldNumber = 2;
  inline double torquedot(int index) const;
  inline void set_torquedot(int index, double value);
  inline void add_torquedot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      torquedot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_torquedot();

  // repeated double theta = 4;
  inline int theta_size() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 4;
  inline double theta(int index) const;
  inline void set_theta(int index, double value);
  inline void add_theta(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      theta() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_theta();

  // repeated double thetadot = 5;
  inline int thetadot_size() const;
  inline void clear_thetadot();
  static const int kThetadotFieldNumber = 5;
  inline double thetadot(int index) const;
  inline void set_thetadot(int index, double value);
  inline void add_thetadot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      thetadot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_thetadot();

  // repeated double thetadotdot = 6;
  inline int thetadotdot_size() const;
  inline void clear_thetadotdot();
  static const int kThetadotdotFieldNumber = 6;
  inline double thetadotdot(int index) const;
  inline void set_thetadotdot(int index, double value);
  inline void add_thetadotdot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      thetadotdot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_thetadotdot();

  // optional int32 completed_spline_idx = 7;
  inline bool has_completed_spline_idx() const;
  inline void clear_completed_spline_idx();
  static const int kCompletedSplineIdxFieldNumber = 7;
  inline ::google::protobuf::int32 completed_spline_idx() const;
  inline void set_completed_spline_idx(::google::protobuf::int32 value);

  // repeated double end_pos = 8;
  inline int end_pos_size() const;
  inline void clear_end_pos();
  static const int kEndPosFieldNumber = 8;
  inline double end_pos(int index) const;
  inline void set_end_pos(int index, double value);
  inline void add_end_pos(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      end_pos() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_end_pos();

  // repeated double end_rot = 9;
  inline int end_rot_size() const;
  inline void clear_end_rot();
  static const int kEndRotFieldNumber = 9;
  inline double end_rot(int index) const;
  inline void set_end_rot(int index, double value);
  inline void add_end_rot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      end_rot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_end_rot();

  // repeated double J = 10;
  inline int j_size() const;
  inline void clear_j();
  static const int kJFieldNumber = 10;
  inline double j(int index) const;
  inline void set_j(int index, double value);
  inline void add_j(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      j() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_j();

  // repeated double G = 11;
  inline int g_size() const;
  inline void clear_g();
  static const int kGFieldNumber = 11;
  inline double g(int index) const;
  inline void set_g(int index, double value);
  inline void add_g(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      g() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_g();

  // repeated double end_twist = 12;
  inline int end_twist_size() const;
  inline void clear_end_twist();
  static const int kEndTwistFieldNumber = 12;
  inline double end_twist(int index) const;
  inline void set_end_twist(int index, double value);
  inline void add_end_twist(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      end_twist() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_end_twist();

  // repeated int32 pwm_cmd = 13;
  inline int pwm_cmd_size() const;
  inline void clear_pwm_cmd();
  static const int kPwmCmdFieldNumber = 13;
  inline ::google::protobuf::int32 pwm_cmd(int index) const;
  inline void set_pwm_cmd(int index, ::google::protobuf::int32 value);
  inline void add_pwm_cmd(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pwm_cmd() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pwm_cmd();

  // @@protoc_insertion_point(class_scope:M3BaseHumanoidStatus)
 private:
  inline void set_has_completed_spline_idx();
  inline void clear_has_completed_spline_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > torque_;
  ::google::protobuf::RepeatedField< double > torquedot_;
  ::google::protobuf::RepeatedField< double > theta_;
  ::google::protobuf::RepeatedField< double > thetadot_;
  ::google::protobuf::RepeatedField< double > thetadotdot_;
  ::google::protobuf::RepeatedField< double > end_pos_;
  ::google::protobuf::RepeatedField< double > end_rot_;
  ::google::protobuf::RepeatedField< double > j_;
  ::google::protobuf::RepeatedField< double > g_;
  ::google::protobuf::RepeatedField< double > end_twist_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pwm_cmd_;
  ::google::protobuf::int32 completed_spline_idx_;
  friend void  protobuf_AddDesc_humanoid_2eproto();
  friend void protobuf_AssignDesc_humanoid_2eproto();
  friend void protobuf_ShutdownFile_humanoid_2eproto();

  void InitAsDefaultInstance();
  static M3BaseHumanoidStatus* default_instance_;
};
// -------------------------------------------------------------------

class M3BaseHumanoidCommand : public ::google::protobuf::Message {
 public:
  M3BaseHumanoidCommand();
  virtual ~M3BaseHumanoidCommand();

  M3BaseHumanoidCommand(const M3BaseHumanoidCommand& from);

  inline M3BaseHumanoidCommand& operator=(const M3BaseHumanoidCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3BaseHumanoidCommand& default_instance();

  void Swap(M3BaseHumanoidCommand* other);

  // implements Message ----------------------------------------------

  M3BaseHumanoidCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3BaseHumanoidCommand& from);
  void MergeFrom(const M3BaseHumanoidCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool cmd_enabled = 10;
  inline int cmd_enabled_size() const;
  inline void clear_cmd_enabled();
  static const int kCmdEnabledFieldNumber = 10;
  inline bool cmd_enabled(int index) const;
  inline void set_cmd_enabled(int index, bool value);
  inline void add_cmd_enabled(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      cmd_enabled() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_cmd_enabled();

  // repeated double tq_desired = 1;
  inline int tq_desired_size() const;
  inline void clear_tq_desired();
  static const int kTqDesiredFieldNumber = 1;
  inline double tq_desired(int index) const;
  inline void set_tq_desired(int index, double value);
  inline void add_tq_desired(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      tq_desired() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_tq_desired();

  // repeated double q_stiffness = 2;
  inline int q_stiffness_size() const;
  inline void clear_q_stiffness();
  static const int kQStiffnessFieldNumber = 2;
  inline double q_stiffness(int index) const;
  inline void set_q_stiffness(int index, double value);
  inline void add_q_stiffness(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      q_stiffness() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_q_stiffness();

  // repeated .JOINT_ARRAY_MODE ctrl_mode = 3;
  inline int ctrl_mode_size() const;
  inline void clear_ctrl_mode();
  static const int kCtrlModeFieldNumber = 3;
  inline ::JOINT_ARRAY_MODE ctrl_mode(int index) const;
  inline void set_ctrl_mode(int index, ::JOINT_ARRAY_MODE value);
  inline void add_ctrl_mode(::JOINT_ARRAY_MODE value);
  inline const ::google::protobuf::RepeatedField<int>& ctrl_mode() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_ctrl_mode();

  // repeated double q_desired = 4;
  inline int q_desired_size() const;
  inline void clear_q_desired();
  static const int kQDesiredFieldNumber = 4;
  inline double q_desired(int index) const;
  inline void set_q_desired(int index, double value);
  inline void add_q_desired(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      q_desired() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_q_desired();

  // repeated .M3JointVia vias = 5;
  inline int vias_size() const;
  inline void clear_vias();
  static const int kViasFieldNumber = 5;
  inline const ::M3JointVia& vias(int index) const;
  inline ::M3JointVia* mutable_vias(int index);
  inline ::M3JointVia* add_vias();
  inline const ::google::protobuf::RepeatedPtrField< ::M3JointVia >&
      vias() const;
  inline ::google::protobuf::RepeatedPtrField< ::M3JointVia >*
      mutable_vias();

  // repeated double qdot_desired = 6;
  inline int qdot_desired_size() const;
  inline void clear_qdot_desired();
  static const int kQdotDesiredFieldNumber = 6;
  inline double qdot_desired(int index) const;
  inline void set_qdot_desired(int index, double value);
  inline void add_qdot_desired(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      qdot_desired() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_qdot_desired();

  // repeated double q_slew_rate = 7;
  inline int q_slew_rate_size() const;
  inline void clear_q_slew_rate();
  static const int kQSlewRateFieldNumber = 7;
  inline double q_slew_rate(int index) const;
  inline void set_q_slew_rate(int index, double value);
  inline void add_q_slew_rate(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      q_slew_rate() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_q_slew_rate();

  // repeated double pwm_desired = 8;
  inline int pwm_desired_size() const;
  inline void clear_pwm_desired();
  static const int kPwmDesiredFieldNumber = 8;
  inline double pwm_desired(int index) const;
  inline void set_pwm_desired(int index, double value);
  inline void add_pwm_desired(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pwm_desired() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pwm_desired();

  // repeated .SMOOTHING_MODE smoothing_mode = 9;
  inline int smoothing_mode_size() const;
  inline void clear_smoothing_mode();
  static const int kSmoothingModeFieldNumber = 9;
  inline ::SMOOTHING_MODE smoothing_mode(int index) const;
  inline void set_smoothing_mode(int index, ::SMOOTHING_MODE value);
  inline void add_smoothing_mode(::SMOOTHING_MODE value);
  inline const ::google::protobuf::RepeatedField<int>& smoothing_mode() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_smoothing_mode();

  // @@protoc_insertion_point(class_scope:M3BaseHumanoidCommand)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< bool > cmd_enabled_;
  ::google::protobuf::RepeatedField< double > tq_desired_;
  ::google::protobuf::RepeatedField< double > q_stiffness_;
  ::google::protobuf::RepeatedField<int> ctrl_mode_;
  ::google::protobuf::RepeatedField< double > q_desired_;
  ::google::protobuf::RepeatedPtrField< ::M3JointVia > vias_;
  ::google::protobuf::RepeatedField< double > qdot_desired_;
  ::google::protobuf::RepeatedField< double > q_slew_rate_;
  ::google::protobuf::RepeatedField< double > pwm_desired_;
  ::google::protobuf::RepeatedField<int> smoothing_mode_;
  friend void  protobuf_AddDesc_humanoid_2eproto();
  friend void protobuf_AssignDesc_humanoid_2eproto();
  friend void protobuf_ShutdownFile_humanoid_2eproto();

  void InitAsDefaultInstance();
  static M3BaseHumanoidCommand* default_instance_;
};
// -------------------------------------------------------------------

class M3BaseHumanoidParam : public ::google::protobuf::Message {
 public:
  M3BaseHumanoidParam();
  virtual ~M3BaseHumanoidParam();

  M3BaseHumanoidParam(const M3BaseHumanoidParam& from);

  inline M3BaseHumanoidParam& operator=(const M3BaseHumanoidParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3BaseHumanoidParam& default_instance();

  void Swap(M3BaseHumanoidParam* other);

  // implements Message ----------------------------------------------

  M3BaseHumanoidParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3BaseHumanoidParam& from);
  void MergeFrom(const M3BaseHumanoidParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double payload_mass = 1;
  inline bool has_payload_mass() const;
  inline void clear_payload_mass();
  static const int kPayloadMassFieldNumber = 1;
  inline double payload_mass() const;
  inline void set_payload_mass(double value);

  // repeated double payload_com = 2;
  inline int payload_com_size() const;
  inline void clear_payload_com();
  static const int kPayloadComFieldNumber = 2;
  inline double payload_com(int index) const;
  inline void set_payload_com(int index, double value);
  inline void add_payload_com(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      payload_com() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_payload_com();

  // repeated double payload_inertia = 3;
  inline int payload_inertia_size() const;
  inline void clear_payload_inertia();
  static const int kPayloadInertiaFieldNumber = 3;
  inline double payload_inertia(int index) const;
  inline void set_payload_inertia(int index, double value);
  inline void add_payload_inertia(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      payload_inertia() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_payload_inertia();

  // optional bool use_velocities = 4;
  inline bool has_use_velocities() const;
  inline void clear_use_velocities();
  static const int kUseVelocitiesFieldNumber = 4;
  inline bool use_velocities() const;
  inline void set_use_velocities(bool value);

  // optional bool use_accelerations = 5;
  inline bool has_use_accelerations() const;
  inline void clear_use_accelerations();
  static const int kUseAccelerationsFieldNumber = 5;
  inline bool use_accelerations() const;
  inline void set_use_accelerations(bool value);

  // @@protoc_insertion_point(class_scope:M3BaseHumanoidParam)
 private:
  inline void set_has_payload_mass();
  inline void clear_has_payload_mass();
  inline void set_has_use_velocities();
  inline void clear_has_use_velocities();
  inline void set_has_use_accelerations();
  inline void clear_has_use_accelerations();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double payload_mass_;
  ::google::protobuf::RepeatedField< double > payload_com_;
  ::google::protobuf::RepeatedField< double > payload_inertia_;
  bool use_velocities_;
  bool use_accelerations_;
  friend void  protobuf_AddDesc_humanoid_2eproto();
  friend void protobuf_AssignDesc_humanoid_2eproto();
  friend void protobuf_ShutdownFile_humanoid_2eproto();

  void InitAsDefaultInstance();
  static M3BaseHumanoidParam* default_instance_;
};
// ===================================================================


// ===================================================================

// M3HumanoidStatus

// optional .M3BaseStatus base = 1;
inline bool M3HumanoidStatus::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3HumanoidStatus::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3HumanoidStatus::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3HumanoidStatus::clear_base() {
  if (base_ != NULL) base_->::M3BaseStatus::Clear();
  clear_has_base();
}
inline const ::M3BaseStatus& M3HumanoidStatus::base() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::M3BaseStatus* M3HumanoidStatus::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::M3BaseStatus;
  // @@protoc_insertion_point(field_mutable:M3HumanoidStatus.base)
  return base_;
}
inline ::M3BaseStatus* M3HumanoidStatus::release_base() {
  clear_has_base();
  ::M3BaseStatus* temp = base_;
  base_ = NULL;
  return temp;
}
inline void M3HumanoidStatus::set_allocated_base(::M3BaseStatus* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidStatus.base)
}

// optional .M3BaseHumanoidStatus right_arm = 2;
inline bool M3HumanoidStatus::has_right_arm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3HumanoidStatus::set_has_right_arm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3HumanoidStatus::clear_has_right_arm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3HumanoidStatus::clear_right_arm() {
  if (right_arm_ != NULL) right_arm_->::M3BaseHumanoidStatus::Clear();
  clear_has_right_arm();
}
inline const ::M3BaseHumanoidStatus& M3HumanoidStatus::right_arm() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.right_arm)
  return right_arm_ != NULL ? *right_arm_ : *default_instance_->right_arm_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::mutable_right_arm() {
  set_has_right_arm();
  if (right_arm_ == NULL) right_arm_ = new ::M3BaseHumanoidStatus;
  // @@protoc_insertion_point(field_mutable:M3HumanoidStatus.right_arm)
  return right_arm_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::release_right_arm() {
  clear_has_right_arm();
  ::M3BaseHumanoidStatus* temp = right_arm_;
  right_arm_ = NULL;
  return temp;
}
inline void M3HumanoidStatus::set_allocated_right_arm(::M3BaseHumanoidStatus* right_arm) {
  delete right_arm_;
  right_arm_ = right_arm;
  if (right_arm) {
    set_has_right_arm();
  } else {
    clear_has_right_arm();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidStatus.right_arm)
}

// optional .M3BaseHumanoidStatus left_arm = 3;
inline bool M3HumanoidStatus::has_left_arm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3HumanoidStatus::set_has_left_arm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3HumanoidStatus::clear_has_left_arm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3HumanoidStatus::clear_left_arm() {
  if (left_arm_ != NULL) left_arm_->::M3BaseHumanoidStatus::Clear();
  clear_has_left_arm();
}
inline const ::M3BaseHumanoidStatus& M3HumanoidStatus::left_arm() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.left_arm)
  return left_arm_ != NULL ? *left_arm_ : *default_instance_->left_arm_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::mutable_left_arm() {
  set_has_left_arm();
  if (left_arm_ == NULL) left_arm_ = new ::M3BaseHumanoidStatus;
  // @@protoc_insertion_point(field_mutable:M3HumanoidStatus.left_arm)
  return left_arm_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::release_left_arm() {
  clear_has_left_arm();
  ::M3BaseHumanoidStatus* temp = left_arm_;
  left_arm_ = NULL;
  return temp;
}
inline void M3HumanoidStatus::set_allocated_left_arm(::M3BaseHumanoidStatus* left_arm) {
  delete left_arm_;
  left_arm_ = left_arm;
  if (left_arm) {
    set_has_left_arm();
  } else {
    clear_has_left_arm();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidStatus.left_arm)
}

// optional .M3BaseHumanoidStatus torso = 4;
inline bool M3HumanoidStatus::has_torso() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3HumanoidStatus::set_has_torso() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3HumanoidStatus::clear_has_torso() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3HumanoidStatus::clear_torso() {
  if (torso_ != NULL) torso_->::M3BaseHumanoidStatus::Clear();
  clear_has_torso();
}
inline const ::M3BaseHumanoidStatus& M3HumanoidStatus::torso() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.torso)
  return torso_ != NULL ? *torso_ : *default_instance_->torso_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::mutable_torso() {
  set_has_torso();
  if (torso_ == NULL) torso_ = new ::M3BaseHumanoidStatus;
  // @@protoc_insertion_point(field_mutable:M3HumanoidStatus.torso)
  return torso_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::release_torso() {
  clear_has_torso();
  ::M3BaseHumanoidStatus* temp = torso_;
  torso_ = NULL;
  return temp;
}
inline void M3HumanoidStatus::set_allocated_torso(::M3BaseHumanoidStatus* torso) {
  delete torso_;
  torso_ = torso;
  if (torso) {
    set_has_torso();
  } else {
    clear_has_torso();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidStatus.torso)
}

// optional .M3BaseHumanoidStatus head = 5;
inline bool M3HumanoidStatus::has_head() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3HumanoidStatus::set_has_head() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3HumanoidStatus::clear_has_head() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3HumanoidStatus::clear_head() {
  if (head_ != NULL) head_->::M3BaseHumanoidStatus::Clear();
  clear_has_head();
}
inline const ::M3BaseHumanoidStatus& M3HumanoidStatus::head() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.head)
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::M3BaseHumanoidStatus;
  // @@protoc_insertion_point(field_mutable:M3HumanoidStatus.head)
  return head_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::release_head() {
  clear_has_head();
  ::M3BaseHumanoidStatus* temp = head_;
  head_ = NULL;
  return temp;
}
inline void M3HumanoidStatus::set_allocated_head(::M3BaseHumanoidStatus* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidStatus.head)
}

// optional .M3BaseHumanoidStatus right_hand = 6;
inline bool M3HumanoidStatus::has_right_hand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3HumanoidStatus::set_has_right_hand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3HumanoidStatus::clear_has_right_hand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3HumanoidStatus::clear_right_hand() {
  if (right_hand_ != NULL) right_hand_->::M3BaseHumanoidStatus::Clear();
  clear_has_right_hand();
}
inline const ::M3BaseHumanoidStatus& M3HumanoidStatus::right_hand() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.right_hand)
  return right_hand_ != NULL ? *right_hand_ : *default_instance_->right_hand_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::mutable_right_hand() {
  set_has_right_hand();
  if (right_hand_ == NULL) right_hand_ = new ::M3BaseHumanoidStatus;
  // @@protoc_insertion_point(field_mutable:M3HumanoidStatus.right_hand)
  return right_hand_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::release_right_hand() {
  clear_has_right_hand();
  ::M3BaseHumanoidStatus* temp = right_hand_;
  right_hand_ = NULL;
  return temp;
}
inline void M3HumanoidStatus::set_allocated_right_hand(::M3BaseHumanoidStatus* right_hand) {
  delete right_hand_;
  right_hand_ = right_hand;
  if (right_hand) {
    set_has_right_hand();
  } else {
    clear_has_right_hand();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidStatus.right_hand)
}

// optional .M3BaseHumanoidStatus left_hand = 7;
inline bool M3HumanoidStatus::has_left_hand() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void M3HumanoidStatus::set_has_left_hand() {
  _has_bits_[0] |= 0x00000040u;
}
inline void M3HumanoidStatus::clear_has_left_hand() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void M3HumanoidStatus::clear_left_hand() {
  if (left_hand_ != NULL) left_hand_->::M3BaseHumanoidStatus::Clear();
  clear_has_left_hand();
}
inline const ::M3BaseHumanoidStatus& M3HumanoidStatus::left_hand() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.left_hand)
  return left_hand_ != NULL ? *left_hand_ : *default_instance_->left_hand_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::mutable_left_hand() {
  set_has_left_hand();
  if (left_hand_ == NULL) left_hand_ = new ::M3BaseHumanoidStatus;
  // @@protoc_insertion_point(field_mutable:M3HumanoidStatus.left_hand)
  return left_hand_;
}
inline ::M3BaseHumanoidStatus* M3HumanoidStatus::release_left_hand() {
  clear_has_left_hand();
  ::M3BaseHumanoidStatus* temp = left_hand_;
  left_hand_ = NULL;
  return temp;
}
inline void M3HumanoidStatus::set_allocated_left_hand(::M3BaseHumanoidStatus* left_hand) {
  delete left_hand_;
  left_hand_ = left_hand;
  if (left_hand) {
    set_has_left_hand();
  } else {
    clear_has_left_hand();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidStatus.left_hand)
}

// repeated double right_eye_rot = 8;
inline int M3HumanoidStatus::right_eye_rot_size() const {
  return right_eye_rot_.size();
}
inline void M3HumanoidStatus::clear_right_eye_rot() {
  right_eye_rot_.Clear();
}
inline double M3HumanoidStatus::right_eye_rot(int index) const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.right_eye_rot)
  return right_eye_rot_.Get(index);
}
inline void M3HumanoidStatus::set_right_eye_rot(int index, double value) {
  right_eye_rot_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3HumanoidStatus.right_eye_rot)
}
inline void M3HumanoidStatus::add_right_eye_rot(double value) {
  right_eye_rot_.Add(value);
  // @@protoc_insertion_point(field_add:M3HumanoidStatus.right_eye_rot)
}
inline const ::google::protobuf::RepeatedField< double >&
M3HumanoidStatus::right_eye_rot() const {
  // @@protoc_insertion_point(field_list:M3HumanoidStatus.right_eye_rot)
  return right_eye_rot_;
}
inline ::google::protobuf::RepeatedField< double >*
M3HumanoidStatus::mutable_right_eye_rot() {
  // @@protoc_insertion_point(field_mutable_list:M3HumanoidStatus.right_eye_rot)
  return &right_eye_rot_;
}

// repeated double left_eye_rot = 9;
inline int M3HumanoidStatus::left_eye_rot_size() const {
  return left_eye_rot_.size();
}
inline void M3HumanoidStatus::clear_left_eye_rot() {
  left_eye_rot_.Clear();
}
inline double M3HumanoidStatus::left_eye_rot(int index) const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.left_eye_rot)
  return left_eye_rot_.Get(index);
}
inline void M3HumanoidStatus::set_left_eye_rot(int index, double value) {
  left_eye_rot_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3HumanoidStatus.left_eye_rot)
}
inline void M3HumanoidStatus::add_left_eye_rot(double value) {
  left_eye_rot_.Add(value);
  // @@protoc_insertion_point(field_add:M3HumanoidStatus.left_eye_rot)
}
inline const ::google::protobuf::RepeatedField< double >&
M3HumanoidStatus::left_eye_rot() const {
  // @@protoc_insertion_point(field_list:M3HumanoidStatus.left_eye_rot)
  return left_eye_rot_;
}
inline ::google::protobuf::RepeatedField< double >*
M3HumanoidStatus::mutable_left_eye_rot() {
  // @@protoc_insertion_point(field_mutable_list:M3HumanoidStatus.left_eye_rot)
  return &left_eye_rot_;
}

// repeated double right_eye_pos = 10;
inline int M3HumanoidStatus::right_eye_pos_size() const {
  return right_eye_pos_.size();
}
inline void M3HumanoidStatus::clear_right_eye_pos() {
  right_eye_pos_.Clear();
}
inline double M3HumanoidStatus::right_eye_pos(int index) const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.right_eye_pos)
  return right_eye_pos_.Get(index);
}
inline void M3HumanoidStatus::set_right_eye_pos(int index, double value) {
  right_eye_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3HumanoidStatus.right_eye_pos)
}
inline void M3HumanoidStatus::add_right_eye_pos(double value) {
  right_eye_pos_.Add(value);
  // @@protoc_insertion_point(field_add:M3HumanoidStatus.right_eye_pos)
}
inline const ::google::protobuf::RepeatedField< double >&
M3HumanoidStatus::right_eye_pos() const {
  // @@protoc_insertion_point(field_list:M3HumanoidStatus.right_eye_pos)
  return right_eye_pos_;
}
inline ::google::protobuf::RepeatedField< double >*
M3HumanoidStatus::mutable_right_eye_pos() {
  // @@protoc_insertion_point(field_mutable_list:M3HumanoidStatus.right_eye_pos)
  return &right_eye_pos_;
}

// repeated double left_eye_pos = 11;
inline int M3HumanoidStatus::left_eye_pos_size() const {
  return left_eye_pos_.size();
}
inline void M3HumanoidStatus::clear_left_eye_pos() {
  left_eye_pos_.Clear();
}
inline double M3HumanoidStatus::left_eye_pos(int index) const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.left_eye_pos)
  return left_eye_pos_.Get(index);
}
inline void M3HumanoidStatus::set_left_eye_pos(int index, double value) {
  left_eye_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3HumanoidStatus.left_eye_pos)
}
inline void M3HumanoidStatus::add_left_eye_pos(double value) {
  left_eye_pos_.Add(value);
  // @@protoc_insertion_point(field_add:M3HumanoidStatus.left_eye_pos)
}
inline const ::google::protobuf::RepeatedField< double >&
M3HumanoidStatus::left_eye_pos() const {
  // @@protoc_insertion_point(field_list:M3HumanoidStatus.left_eye_pos)
  return left_eye_pos_;
}
inline ::google::protobuf::RepeatedField< double >*
M3HumanoidStatus::mutable_left_eye_pos() {
  // @@protoc_insertion_point(field_mutable_list:M3HumanoidStatus.left_eye_pos)
  return &left_eye_pos_;
}

// optional bool motor_enabled = 12;
inline bool M3HumanoidStatus::has_motor_enabled() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void M3HumanoidStatus::set_has_motor_enabled() {
  _has_bits_[0] |= 0x00000800u;
}
inline void M3HumanoidStatus::clear_has_motor_enabled() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void M3HumanoidStatus::clear_motor_enabled() {
  motor_enabled_ = false;
  clear_has_motor_enabled();
}
inline bool M3HumanoidStatus::motor_enabled() const {
  // @@protoc_insertion_point(field_get:M3HumanoidStatus.motor_enabled)
  return motor_enabled_;
}
inline void M3HumanoidStatus::set_motor_enabled(bool value) {
  set_has_motor_enabled();
  motor_enabled_ = value;
  // @@protoc_insertion_point(field_set:M3HumanoidStatus.motor_enabled)
}

// -------------------------------------------------------------------

// M3HumanoidCommand

// optional .M3BaseHumanoidCommand right_arm = 1;
inline bool M3HumanoidCommand::has_right_arm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3HumanoidCommand::set_has_right_arm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3HumanoidCommand::clear_has_right_arm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3HumanoidCommand::clear_right_arm() {
  if (right_arm_ != NULL) right_arm_->::M3BaseHumanoidCommand::Clear();
  clear_has_right_arm();
}
inline const ::M3BaseHumanoidCommand& M3HumanoidCommand::right_arm() const {
  // @@protoc_insertion_point(field_get:M3HumanoidCommand.right_arm)
  return right_arm_ != NULL ? *right_arm_ : *default_instance_->right_arm_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::mutable_right_arm() {
  set_has_right_arm();
  if (right_arm_ == NULL) right_arm_ = new ::M3BaseHumanoidCommand;
  // @@protoc_insertion_point(field_mutable:M3HumanoidCommand.right_arm)
  return right_arm_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::release_right_arm() {
  clear_has_right_arm();
  ::M3BaseHumanoidCommand* temp = right_arm_;
  right_arm_ = NULL;
  return temp;
}
inline void M3HumanoidCommand::set_allocated_right_arm(::M3BaseHumanoidCommand* right_arm) {
  delete right_arm_;
  right_arm_ = right_arm;
  if (right_arm) {
    set_has_right_arm();
  } else {
    clear_has_right_arm();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidCommand.right_arm)
}

// optional .M3BaseHumanoidCommand left_arm = 2;
inline bool M3HumanoidCommand::has_left_arm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3HumanoidCommand::set_has_left_arm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3HumanoidCommand::clear_has_left_arm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3HumanoidCommand::clear_left_arm() {
  if (left_arm_ != NULL) left_arm_->::M3BaseHumanoidCommand::Clear();
  clear_has_left_arm();
}
inline const ::M3BaseHumanoidCommand& M3HumanoidCommand::left_arm() const {
  // @@protoc_insertion_point(field_get:M3HumanoidCommand.left_arm)
  return left_arm_ != NULL ? *left_arm_ : *default_instance_->left_arm_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::mutable_left_arm() {
  set_has_left_arm();
  if (left_arm_ == NULL) left_arm_ = new ::M3BaseHumanoidCommand;
  // @@protoc_insertion_point(field_mutable:M3HumanoidCommand.left_arm)
  return left_arm_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::release_left_arm() {
  clear_has_left_arm();
  ::M3BaseHumanoidCommand* temp = left_arm_;
  left_arm_ = NULL;
  return temp;
}
inline void M3HumanoidCommand::set_allocated_left_arm(::M3BaseHumanoidCommand* left_arm) {
  delete left_arm_;
  left_arm_ = left_arm;
  if (left_arm) {
    set_has_left_arm();
  } else {
    clear_has_left_arm();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidCommand.left_arm)
}

// optional .M3BaseHumanoidCommand torso = 3;
inline bool M3HumanoidCommand::has_torso() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3HumanoidCommand::set_has_torso() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3HumanoidCommand::clear_has_torso() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3HumanoidCommand::clear_torso() {
  if (torso_ != NULL) torso_->::M3BaseHumanoidCommand::Clear();
  clear_has_torso();
}
inline const ::M3BaseHumanoidCommand& M3HumanoidCommand::torso() const {
  // @@protoc_insertion_point(field_get:M3HumanoidCommand.torso)
  return torso_ != NULL ? *torso_ : *default_instance_->torso_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::mutable_torso() {
  set_has_torso();
  if (torso_ == NULL) torso_ = new ::M3BaseHumanoidCommand;
  // @@protoc_insertion_point(field_mutable:M3HumanoidCommand.torso)
  return torso_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::release_torso() {
  clear_has_torso();
  ::M3BaseHumanoidCommand* temp = torso_;
  torso_ = NULL;
  return temp;
}
inline void M3HumanoidCommand::set_allocated_torso(::M3BaseHumanoidCommand* torso) {
  delete torso_;
  torso_ = torso;
  if (torso) {
    set_has_torso();
  } else {
    clear_has_torso();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidCommand.torso)
}

// optional .M3BaseHumanoidCommand head = 4;
inline bool M3HumanoidCommand::has_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3HumanoidCommand::set_has_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3HumanoidCommand::clear_has_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3HumanoidCommand::clear_head() {
  if (head_ != NULL) head_->::M3BaseHumanoidCommand::Clear();
  clear_has_head();
}
inline const ::M3BaseHumanoidCommand& M3HumanoidCommand::head() const {
  // @@protoc_insertion_point(field_get:M3HumanoidCommand.head)
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::M3BaseHumanoidCommand;
  // @@protoc_insertion_point(field_mutable:M3HumanoidCommand.head)
  return head_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::release_head() {
  clear_has_head();
  ::M3BaseHumanoidCommand* temp = head_;
  head_ = NULL;
  return temp;
}
inline void M3HumanoidCommand::set_allocated_head(::M3BaseHumanoidCommand* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidCommand.head)
}

// optional .M3BaseHumanoidCommand right_hand = 5;
inline bool M3HumanoidCommand::has_right_hand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3HumanoidCommand::set_has_right_hand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3HumanoidCommand::clear_has_right_hand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3HumanoidCommand::clear_right_hand() {
  if (right_hand_ != NULL) right_hand_->::M3BaseHumanoidCommand::Clear();
  clear_has_right_hand();
}
inline const ::M3BaseHumanoidCommand& M3HumanoidCommand::right_hand() const {
  // @@protoc_insertion_point(field_get:M3HumanoidCommand.right_hand)
  return right_hand_ != NULL ? *right_hand_ : *default_instance_->right_hand_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::mutable_right_hand() {
  set_has_right_hand();
  if (right_hand_ == NULL) right_hand_ = new ::M3BaseHumanoidCommand;
  // @@protoc_insertion_point(field_mutable:M3HumanoidCommand.right_hand)
  return right_hand_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::release_right_hand() {
  clear_has_right_hand();
  ::M3BaseHumanoidCommand* temp = right_hand_;
  right_hand_ = NULL;
  return temp;
}
inline void M3HumanoidCommand::set_allocated_right_hand(::M3BaseHumanoidCommand* right_hand) {
  delete right_hand_;
  right_hand_ = right_hand;
  if (right_hand) {
    set_has_right_hand();
  } else {
    clear_has_right_hand();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidCommand.right_hand)
}

// optional .M3BaseHumanoidCommand left_hand = 6;
inline bool M3HumanoidCommand::has_left_hand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3HumanoidCommand::set_has_left_hand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3HumanoidCommand::clear_has_left_hand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3HumanoidCommand::clear_left_hand() {
  if (left_hand_ != NULL) left_hand_->::M3BaseHumanoidCommand::Clear();
  clear_has_left_hand();
}
inline const ::M3BaseHumanoidCommand& M3HumanoidCommand::left_hand() const {
  // @@protoc_insertion_point(field_get:M3HumanoidCommand.left_hand)
  return left_hand_ != NULL ? *left_hand_ : *default_instance_->left_hand_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::mutable_left_hand() {
  set_has_left_hand();
  if (left_hand_ == NULL) left_hand_ = new ::M3BaseHumanoidCommand;
  // @@protoc_insertion_point(field_mutable:M3HumanoidCommand.left_hand)
  return left_hand_;
}
inline ::M3BaseHumanoidCommand* M3HumanoidCommand::release_left_hand() {
  clear_has_left_hand();
  ::M3BaseHumanoidCommand* temp = left_hand_;
  left_hand_ = NULL;
  return temp;
}
inline void M3HumanoidCommand::set_allocated_left_hand(::M3BaseHumanoidCommand* left_hand) {
  delete left_hand_;
  left_hand_ = left_hand;
  if (left_hand) {
    set_has_left_hand();
  } else {
    clear_has_left_hand();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidCommand.left_hand)
}

// optional bool enable_motor = 7;
inline bool M3HumanoidCommand::has_enable_motor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void M3HumanoidCommand::set_has_enable_motor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void M3HumanoidCommand::clear_has_enable_motor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void M3HumanoidCommand::clear_enable_motor() {
  enable_motor_ = false;
  clear_has_enable_motor();
}
inline bool M3HumanoidCommand::enable_motor() const {
  // @@protoc_insertion_point(field_get:M3HumanoidCommand.enable_motor)
  return enable_motor_;
}
inline void M3HumanoidCommand::set_enable_motor(bool value) {
  set_has_enable_motor();
  enable_motor_ = value;
  // @@protoc_insertion_point(field_set:M3HumanoidCommand.enable_motor)
}

// -------------------------------------------------------------------

// M3HumanoidParam

// optional .M3BaseHumanoidParam right_arm = 1;
inline bool M3HumanoidParam::has_right_arm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3HumanoidParam::set_has_right_arm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3HumanoidParam::clear_has_right_arm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3HumanoidParam::clear_right_arm() {
  if (right_arm_ != NULL) right_arm_->::M3BaseHumanoidParam::Clear();
  clear_has_right_arm();
}
inline const ::M3BaseHumanoidParam& M3HumanoidParam::right_arm() const {
  // @@protoc_insertion_point(field_get:M3HumanoidParam.right_arm)
  return right_arm_ != NULL ? *right_arm_ : *default_instance_->right_arm_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::mutable_right_arm() {
  set_has_right_arm();
  if (right_arm_ == NULL) right_arm_ = new ::M3BaseHumanoidParam;
  // @@protoc_insertion_point(field_mutable:M3HumanoidParam.right_arm)
  return right_arm_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::release_right_arm() {
  clear_has_right_arm();
  ::M3BaseHumanoidParam* temp = right_arm_;
  right_arm_ = NULL;
  return temp;
}
inline void M3HumanoidParam::set_allocated_right_arm(::M3BaseHumanoidParam* right_arm) {
  delete right_arm_;
  right_arm_ = right_arm;
  if (right_arm) {
    set_has_right_arm();
  } else {
    clear_has_right_arm();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidParam.right_arm)
}

// optional .M3BaseHumanoidParam left_arm = 2;
inline bool M3HumanoidParam::has_left_arm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3HumanoidParam::set_has_left_arm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3HumanoidParam::clear_has_left_arm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3HumanoidParam::clear_left_arm() {
  if (left_arm_ != NULL) left_arm_->::M3BaseHumanoidParam::Clear();
  clear_has_left_arm();
}
inline const ::M3BaseHumanoidParam& M3HumanoidParam::left_arm() const {
  // @@protoc_insertion_point(field_get:M3HumanoidParam.left_arm)
  return left_arm_ != NULL ? *left_arm_ : *default_instance_->left_arm_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::mutable_left_arm() {
  set_has_left_arm();
  if (left_arm_ == NULL) left_arm_ = new ::M3BaseHumanoidParam;
  // @@protoc_insertion_point(field_mutable:M3HumanoidParam.left_arm)
  return left_arm_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::release_left_arm() {
  clear_has_left_arm();
  ::M3BaseHumanoidParam* temp = left_arm_;
  left_arm_ = NULL;
  return temp;
}
inline void M3HumanoidParam::set_allocated_left_arm(::M3BaseHumanoidParam* left_arm) {
  delete left_arm_;
  left_arm_ = left_arm;
  if (left_arm) {
    set_has_left_arm();
  } else {
    clear_has_left_arm();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidParam.left_arm)
}

// optional .M3BaseHumanoidParam torso = 3;
inline bool M3HumanoidParam::has_torso() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3HumanoidParam::set_has_torso() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3HumanoidParam::clear_has_torso() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3HumanoidParam::clear_torso() {
  if (torso_ != NULL) torso_->::M3BaseHumanoidParam::Clear();
  clear_has_torso();
}
inline const ::M3BaseHumanoidParam& M3HumanoidParam::torso() const {
  // @@protoc_insertion_point(field_get:M3HumanoidParam.torso)
  return torso_ != NULL ? *torso_ : *default_instance_->torso_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::mutable_torso() {
  set_has_torso();
  if (torso_ == NULL) torso_ = new ::M3BaseHumanoidParam;
  // @@protoc_insertion_point(field_mutable:M3HumanoidParam.torso)
  return torso_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::release_torso() {
  clear_has_torso();
  ::M3BaseHumanoidParam* temp = torso_;
  torso_ = NULL;
  return temp;
}
inline void M3HumanoidParam::set_allocated_torso(::M3BaseHumanoidParam* torso) {
  delete torso_;
  torso_ = torso;
  if (torso) {
    set_has_torso();
  } else {
    clear_has_torso();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidParam.torso)
}

// optional .M3BaseHumanoidParam head = 4;
inline bool M3HumanoidParam::has_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3HumanoidParam::set_has_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3HumanoidParam::clear_has_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3HumanoidParam::clear_head() {
  if (head_ != NULL) head_->::M3BaseHumanoidParam::Clear();
  clear_has_head();
}
inline const ::M3BaseHumanoidParam& M3HumanoidParam::head() const {
  // @@protoc_insertion_point(field_get:M3HumanoidParam.head)
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::M3BaseHumanoidParam;
  // @@protoc_insertion_point(field_mutable:M3HumanoidParam.head)
  return head_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::release_head() {
  clear_has_head();
  ::M3BaseHumanoidParam* temp = head_;
  head_ = NULL;
  return temp;
}
inline void M3HumanoidParam::set_allocated_head(::M3BaseHumanoidParam* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidParam.head)
}

// optional .M3BaseHumanoidParam right_hand = 5;
inline bool M3HumanoidParam::has_right_hand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3HumanoidParam::set_has_right_hand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3HumanoidParam::clear_has_right_hand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3HumanoidParam::clear_right_hand() {
  if (right_hand_ != NULL) right_hand_->::M3BaseHumanoidParam::Clear();
  clear_has_right_hand();
}
inline const ::M3BaseHumanoidParam& M3HumanoidParam::right_hand() const {
  // @@protoc_insertion_point(field_get:M3HumanoidParam.right_hand)
  return right_hand_ != NULL ? *right_hand_ : *default_instance_->right_hand_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::mutable_right_hand() {
  set_has_right_hand();
  if (right_hand_ == NULL) right_hand_ = new ::M3BaseHumanoidParam;
  // @@protoc_insertion_point(field_mutable:M3HumanoidParam.right_hand)
  return right_hand_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::release_right_hand() {
  clear_has_right_hand();
  ::M3BaseHumanoidParam* temp = right_hand_;
  right_hand_ = NULL;
  return temp;
}
inline void M3HumanoidParam::set_allocated_right_hand(::M3BaseHumanoidParam* right_hand) {
  delete right_hand_;
  right_hand_ = right_hand;
  if (right_hand) {
    set_has_right_hand();
  } else {
    clear_has_right_hand();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidParam.right_hand)
}

// optional .M3BaseHumanoidParam left_hand = 6;
inline bool M3HumanoidParam::has_left_hand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3HumanoidParam::set_has_left_hand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3HumanoidParam::clear_has_left_hand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3HumanoidParam::clear_left_hand() {
  if (left_hand_ != NULL) left_hand_->::M3BaseHumanoidParam::Clear();
  clear_has_left_hand();
}
inline const ::M3BaseHumanoidParam& M3HumanoidParam::left_hand() const {
  // @@protoc_insertion_point(field_get:M3HumanoidParam.left_hand)
  return left_hand_ != NULL ? *left_hand_ : *default_instance_->left_hand_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::mutable_left_hand() {
  set_has_left_hand();
  if (left_hand_ == NULL) left_hand_ = new ::M3BaseHumanoidParam;
  // @@protoc_insertion_point(field_mutable:M3HumanoidParam.left_hand)
  return left_hand_;
}
inline ::M3BaseHumanoidParam* M3HumanoidParam::release_left_hand() {
  clear_has_left_hand();
  ::M3BaseHumanoidParam* temp = left_hand_;
  left_hand_ = NULL;
  return temp;
}
inline void M3HumanoidParam::set_allocated_left_hand(::M3BaseHumanoidParam* left_hand) {
  delete left_hand_;
  left_hand_ = left_hand;
  if (left_hand) {
    set_has_left_hand();
  } else {
    clear_has_left_hand();
  }
  // @@protoc_insertion_point(field_set_allocated:M3HumanoidParam.left_hand)
}

// -------------------------------------------------------------------

// M3BaseHumanoidStatus

// repeated double torque = 1;
inline int M3BaseHumanoidStatus::torque_size() const {
  return torque_.size();
}
inline void M3BaseHumanoidStatus::clear_torque() {
  torque_.Clear();
}
inline double M3BaseHumanoidStatus::torque(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.torque)
  return torque_.Get(index);
}
inline void M3BaseHumanoidStatus::set_torque(int index, double value) {
  torque_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.torque)
}
inline void M3BaseHumanoidStatus::add_torque(double value) {
  torque_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.torque)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::torque() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.torque)
  return torque_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_torque() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.torque)
  return &torque_;
}

// repeated double torquedot = 2;
inline int M3BaseHumanoidStatus::torquedot_size() const {
  return torquedot_.size();
}
inline void M3BaseHumanoidStatus::clear_torquedot() {
  torquedot_.Clear();
}
inline double M3BaseHumanoidStatus::torquedot(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.torquedot)
  return torquedot_.Get(index);
}
inline void M3BaseHumanoidStatus::set_torquedot(int index, double value) {
  torquedot_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.torquedot)
}
inline void M3BaseHumanoidStatus::add_torquedot(double value) {
  torquedot_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.torquedot)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::torquedot() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.torquedot)
  return torquedot_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_torquedot() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.torquedot)
  return &torquedot_;
}

// repeated double theta = 4;
inline int M3BaseHumanoidStatus::theta_size() const {
  return theta_.size();
}
inline void M3BaseHumanoidStatus::clear_theta() {
  theta_.Clear();
}
inline double M3BaseHumanoidStatus::theta(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.theta)
  return theta_.Get(index);
}
inline void M3BaseHumanoidStatus::set_theta(int index, double value) {
  theta_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.theta)
}
inline void M3BaseHumanoidStatus::add_theta(double value) {
  theta_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.theta)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::theta() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.theta)
  return theta_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_theta() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.theta)
  return &theta_;
}

// repeated double thetadot = 5;
inline int M3BaseHumanoidStatus::thetadot_size() const {
  return thetadot_.size();
}
inline void M3BaseHumanoidStatus::clear_thetadot() {
  thetadot_.Clear();
}
inline double M3BaseHumanoidStatus::thetadot(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.thetadot)
  return thetadot_.Get(index);
}
inline void M3BaseHumanoidStatus::set_thetadot(int index, double value) {
  thetadot_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.thetadot)
}
inline void M3BaseHumanoidStatus::add_thetadot(double value) {
  thetadot_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.thetadot)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::thetadot() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.thetadot)
  return thetadot_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_thetadot() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.thetadot)
  return &thetadot_;
}

// repeated double thetadotdot = 6;
inline int M3BaseHumanoidStatus::thetadotdot_size() const {
  return thetadotdot_.size();
}
inline void M3BaseHumanoidStatus::clear_thetadotdot() {
  thetadotdot_.Clear();
}
inline double M3BaseHumanoidStatus::thetadotdot(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.thetadotdot)
  return thetadotdot_.Get(index);
}
inline void M3BaseHumanoidStatus::set_thetadotdot(int index, double value) {
  thetadotdot_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.thetadotdot)
}
inline void M3BaseHumanoidStatus::add_thetadotdot(double value) {
  thetadotdot_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.thetadotdot)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::thetadotdot() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.thetadotdot)
  return thetadotdot_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_thetadotdot() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.thetadotdot)
  return &thetadotdot_;
}

// optional int32 completed_spline_idx = 7;
inline bool M3BaseHumanoidStatus::has_completed_spline_idx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3BaseHumanoidStatus::set_has_completed_spline_idx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3BaseHumanoidStatus::clear_has_completed_spline_idx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3BaseHumanoidStatus::clear_completed_spline_idx() {
  completed_spline_idx_ = 0;
  clear_has_completed_spline_idx();
}
inline ::google::protobuf::int32 M3BaseHumanoidStatus::completed_spline_idx() const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.completed_spline_idx)
  return completed_spline_idx_;
}
inline void M3BaseHumanoidStatus::set_completed_spline_idx(::google::protobuf::int32 value) {
  set_has_completed_spline_idx();
  completed_spline_idx_ = value;
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.completed_spline_idx)
}

// repeated double end_pos = 8;
inline int M3BaseHumanoidStatus::end_pos_size() const {
  return end_pos_.size();
}
inline void M3BaseHumanoidStatus::clear_end_pos() {
  end_pos_.Clear();
}
inline double M3BaseHumanoidStatus::end_pos(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.end_pos)
  return end_pos_.Get(index);
}
inline void M3BaseHumanoidStatus::set_end_pos(int index, double value) {
  end_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.end_pos)
}
inline void M3BaseHumanoidStatus::add_end_pos(double value) {
  end_pos_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.end_pos)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::end_pos() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.end_pos)
  return end_pos_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_end_pos() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.end_pos)
  return &end_pos_;
}

// repeated double end_rot = 9;
inline int M3BaseHumanoidStatus::end_rot_size() const {
  return end_rot_.size();
}
inline void M3BaseHumanoidStatus::clear_end_rot() {
  end_rot_.Clear();
}
inline double M3BaseHumanoidStatus::end_rot(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.end_rot)
  return end_rot_.Get(index);
}
inline void M3BaseHumanoidStatus::set_end_rot(int index, double value) {
  end_rot_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.end_rot)
}
inline void M3BaseHumanoidStatus::add_end_rot(double value) {
  end_rot_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.end_rot)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::end_rot() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.end_rot)
  return end_rot_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_end_rot() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.end_rot)
  return &end_rot_;
}

// repeated double J = 10;
inline int M3BaseHumanoidStatus::j_size() const {
  return j_.size();
}
inline void M3BaseHumanoidStatus::clear_j() {
  j_.Clear();
}
inline double M3BaseHumanoidStatus::j(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.J)
  return j_.Get(index);
}
inline void M3BaseHumanoidStatus::set_j(int index, double value) {
  j_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.J)
}
inline void M3BaseHumanoidStatus::add_j(double value) {
  j_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.J)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::j() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.J)
  return j_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_j() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.J)
  return &j_;
}

// repeated double G = 11;
inline int M3BaseHumanoidStatus::g_size() const {
  return g_.size();
}
inline void M3BaseHumanoidStatus::clear_g() {
  g_.Clear();
}
inline double M3BaseHumanoidStatus::g(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.G)
  return g_.Get(index);
}
inline void M3BaseHumanoidStatus::set_g(int index, double value) {
  g_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.G)
}
inline void M3BaseHumanoidStatus::add_g(double value) {
  g_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.G)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::g() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.G)
  return g_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_g() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.G)
  return &g_;
}

// repeated double end_twist = 12;
inline int M3BaseHumanoidStatus::end_twist_size() const {
  return end_twist_.size();
}
inline void M3BaseHumanoidStatus::clear_end_twist() {
  end_twist_.Clear();
}
inline double M3BaseHumanoidStatus::end_twist(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.end_twist)
  return end_twist_.Get(index);
}
inline void M3BaseHumanoidStatus::set_end_twist(int index, double value) {
  end_twist_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.end_twist)
}
inline void M3BaseHumanoidStatus::add_end_twist(double value) {
  end_twist_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.end_twist)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidStatus::end_twist() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.end_twist)
  return end_twist_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidStatus::mutable_end_twist() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.end_twist)
  return &end_twist_;
}

// repeated int32 pwm_cmd = 13;
inline int M3BaseHumanoidStatus::pwm_cmd_size() const {
  return pwm_cmd_.size();
}
inline void M3BaseHumanoidStatus::clear_pwm_cmd() {
  pwm_cmd_.Clear();
}
inline ::google::protobuf::int32 M3BaseHumanoidStatus::pwm_cmd(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidStatus.pwm_cmd)
  return pwm_cmd_.Get(index);
}
inline void M3BaseHumanoidStatus::set_pwm_cmd(int index, ::google::protobuf::int32 value) {
  pwm_cmd_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidStatus.pwm_cmd)
}
inline void M3BaseHumanoidStatus::add_pwm_cmd(::google::protobuf::int32 value) {
  pwm_cmd_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidStatus.pwm_cmd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
M3BaseHumanoidStatus::pwm_cmd() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidStatus.pwm_cmd)
  return pwm_cmd_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
M3BaseHumanoidStatus::mutable_pwm_cmd() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidStatus.pwm_cmd)
  return &pwm_cmd_;
}

// -------------------------------------------------------------------

// M3BaseHumanoidCommand

// repeated bool cmd_enabled = 10;
inline int M3BaseHumanoidCommand::cmd_enabled_size() const {
  return cmd_enabled_.size();
}
inline void M3BaseHumanoidCommand::clear_cmd_enabled() {
  cmd_enabled_.Clear();
}
inline bool M3BaseHumanoidCommand::cmd_enabled(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.cmd_enabled)
  return cmd_enabled_.Get(index);
}
inline void M3BaseHumanoidCommand::set_cmd_enabled(int index, bool value) {
  cmd_enabled_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.cmd_enabled)
}
inline void M3BaseHumanoidCommand::add_cmd_enabled(bool value) {
  cmd_enabled_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.cmd_enabled)
}
inline const ::google::protobuf::RepeatedField< bool >&
M3BaseHumanoidCommand::cmd_enabled() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.cmd_enabled)
  return cmd_enabled_;
}
inline ::google::protobuf::RepeatedField< bool >*
M3BaseHumanoidCommand::mutable_cmd_enabled() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.cmd_enabled)
  return &cmd_enabled_;
}

// repeated double tq_desired = 1;
inline int M3BaseHumanoidCommand::tq_desired_size() const {
  return tq_desired_.size();
}
inline void M3BaseHumanoidCommand::clear_tq_desired() {
  tq_desired_.Clear();
}
inline double M3BaseHumanoidCommand::tq_desired(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.tq_desired)
  return tq_desired_.Get(index);
}
inline void M3BaseHumanoidCommand::set_tq_desired(int index, double value) {
  tq_desired_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.tq_desired)
}
inline void M3BaseHumanoidCommand::add_tq_desired(double value) {
  tq_desired_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.tq_desired)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidCommand::tq_desired() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.tq_desired)
  return tq_desired_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidCommand::mutable_tq_desired() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.tq_desired)
  return &tq_desired_;
}

// repeated double q_stiffness = 2;
inline int M3BaseHumanoidCommand::q_stiffness_size() const {
  return q_stiffness_.size();
}
inline void M3BaseHumanoidCommand::clear_q_stiffness() {
  q_stiffness_.Clear();
}
inline double M3BaseHumanoidCommand::q_stiffness(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.q_stiffness)
  return q_stiffness_.Get(index);
}
inline void M3BaseHumanoidCommand::set_q_stiffness(int index, double value) {
  q_stiffness_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.q_stiffness)
}
inline void M3BaseHumanoidCommand::add_q_stiffness(double value) {
  q_stiffness_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.q_stiffness)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidCommand::q_stiffness() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.q_stiffness)
  return q_stiffness_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidCommand::mutable_q_stiffness() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.q_stiffness)
  return &q_stiffness_;
}

// repeated .JOINT_ARRAY_MODE ctrl_mode = 3;
inline int M3BaseHumanoidCommand::ctrl_mode_size() const {
  return ctrl_mode_.size();
}
inline void M3BaseHumanoidCommand::clear_ctrl_mode() {
  ctrl_mode_.Clear();
}
inline ::JOINT_ARRAY_MODE M3BaseHumanoidCommand::ctrl_mode(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.ctrl_mode)
  return static_cast< ::JOINT_ARRAY_MODE >(ctrl_mode_.Get(index));
}
inline void M3BaseHumanoidCommand::set_ctrl_mode(int index, ::JOINT_ARRAY_MODE value) {
  assert(::JOINT_ARRAY_MODE_IsValid(value));
  ctrl_mode_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.ctrl_mode)
}
inline void M3BaseHumanoidCommand::add_ctrl_mode(::JOINT_ARRAY_MODE value) {
  assert(::JOINT_ARRAY_MODE_IsValid(value));
  ctrl_mode_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.ctrl_mode)
}
inline const ::google::protobuf::RepeatedField<int>&
M3BaseHumanoidCommand::ctrl_mode() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.ctrl_mode)
  return ctrl_mode_;
}
inline ::google::protobuf::RepeatedField<int>*
M3BaseHumanoidCommand::mutable_ctrl_mode() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.ctrl_mode)
  return &ctrl_mode_;
}

// repeated double q_desired = 4;
inline int M3BaseHumanoidCommand::q_desired_size() const {
  return q_desired_.size();
}
inline void M3BaseHumanoidCommand::clear_q_desired() {
  q_desired_.Clear();
}
inline double M3BaseHumanoidCommand::q_desired(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.q_desired)
  return q_desired_.Get(index);
}
inline void M3BaseHumanoidCommand::set_q_desired(int index, double value) {
  q_desired_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.q_desired)
}
inline void M3BaseHumanoidCommand::add_q_desired(double value) {
  q_desired_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.q_desired)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidCommand::q_desired() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.q_desired)
  return q_desired_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidCommand::mutable_q_desired() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.q_desired)
  return &q_desired_;
}

// repeated .M3JointVia vias = 5;
inline int M3BaseHumanoidCommand::vias_size() const {
  return vias_.size();
}
inline void M3BaseHumanoidCommand::clear_vias() {
  vias_.Clear();
}
inline const ::M3JointVia& M3BaseHumanoidCommand::vias(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.vias)
  return vias_.Get(index);
}
inline ::M3JointVia* M3BaseHumanoidCommand::mutable_vias(int index) {
  // @@protoc_insertion_point(field_mutable:M3BaseHumanoidCommand.vias)
  return vias_.Mutable(index);
}
inline ::M3JointVia* M3BaseHumanoidCommand::add_vias() {
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.vias)
  return vias_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::M3JointVia >&
M3BaseHumanoidCommand::vias() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.vias)
  return vias_;
}
inline ::google::protobuf::RepeatedPtrField< ::M3JointVia >*
M3BaseHumanoidCommand::mutable_vias() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.vias)
  return &vias_;
}

// repeated double qdot_desired = 6;
inline int M3BaseHumanoidCommand::qdot_desired_size() const {
  return qdot_desired_.size();
}
inline void M3BaseHumanoidCommand::clear_qdot_desired() {
  qdot_desired_.Clear();
}
inline double M3BaseHumanoidCommand::qdot_desired(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.qdot_desired)
  return qdot_desired_.Get(index);
}
inline void M3BaseHumanoidCommand::set_qdot_desired(int index, double value) {
  qdot_desired_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.qdot_desired)
}
inline void M3BaseHumanoidCommand::add_qdot_desired(double value) {
  qdot_desired_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.qdot_desired)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidCommand::qdot_desired() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.qdot_desired)
  return qdot_desired_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidCommand::mutable_qdot_desired() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.qdot_desired)
  return &qdot_desired_;
}

// repeated double q_slew_rate = 7;
inline int M3BaseHumanoidCommand::q_slew_rate_size() const {
  return q_slew_rate_.size();
}
inline void M3BaseHumanoidCommand::clear_q_slew_rate() {
  q_slew_rate_.Clear();
}
inline double M3BaseHumanoidCommand::q_slew_rate(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.q_slew_rate)
  return q_slew_rate_.Get(index);
}
inline void M3BaseHumanoidCommand::set_q_slew_rate(int index, double value) {
  q_slew_rate_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.q_slew_rate)
}
inline void M3BaseHumanoidCommand::add_q_slew_rate(double value) {
  q_slew_rate_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.q_slew_rate)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidCommand::q_slew_rate() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.q_slew_rate)
  return q_slew_rate_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidCommand::mutable_q_slew_rate() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.q_slew_rate)
  return &q_slew_rate_;
}

// repeated double pwm_desired = 8;
inline int M3BaseHumanoidCommand::pwm_desired_size() const {
  return pwm_desired_.size();
}
inline void M3BaseHumanoidCommand::clear_pwm_desired() {
  pwm_desired_.Clear();
}
inline double M3BaseHumanoidCommand::pwm_desired(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.pwm_desired)
  return pwm_desired_.Get(index);
}
inline void M3BaseHumanoidCommand::set_pwm_desired(int index, double value) {
  pwm_desired_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.pwm_desired)
}
inline void M3BaseHumanoidCommand::add_pwm_desired(double value) {
  pwm_desired_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.pwm_desired)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidCommand::pwm_desired() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.pwm_desired)
  return pwm_desired_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidCommand::mutable_pwm_desired() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.pwm_desired)
  return &pwm_desired_;
}

// repeated .SMOOTHING_MODE smoothing_mode = 9;
inline int M3BaseHumanoidCommand::smoothing_mode_size() const {
  return smoothing_mode_.size();
}
inline void M3BaseHumanoidCommand::clear_smoothing_mode() {
  smoothing_mode_.Clear();
}
inline ::SMOOTHING_MODE M3BaseHumanoidCommand::smoothing_mode(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidCommand.smoothing_mode)
  return static_cast< ::SMOOTHING_MODE >(smoothing_mode_.Get(index));
}
inline void M3BaseHumanoidCommand::set_smoothing_mode(int index, ::SMOOTHING_MODE value) {
  assert(::SMOOTHING_MODE_IsValid(value));
  smoothing_mode_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidCommand.smoothing_mode)
}
inline void M3BaseHumanoidCommand::add_smoothing_mode(::SMOOTHING_MODE value) {
  assert(::SMOOTHING_MODE_IsValid(value));
  smoothing_mode_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidCommand.smoothing_mode)
}
inline const ::google::protobuf::RepeatedField<int>&
M3BaseHumanoidCommand::smoothing_mode() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidCommand.smoothing_mode)
  return smoothing_mode_;
}
inline ::google::protobuf::RepeatedField<int>*
M3BaseHumanoidCommand::mutable_smoothing_mode() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidCommand.smoothing_mode)
  return &smoothing_mode_;
}

// -------------------------------------------------------------------

// M3BaseHumanoidParam

// optional double payload_mass = 1;
inline bool M3BaseHumanoidParam::has_payload_mass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3BaseHumanoidParam::set_has_payload_mass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3BaseHumanoidParam::clear_has_payload_mass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3BaseHumanoidParam::clear_payload_mass() {
  payload_mass_ = 0;
  clear_has_payload_mass();
}
inline double M3BaseHumanoidParam::payload_mass() const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidParam.payload_mass)
  return payload_mass_;
}
inline void M3BaseHumanoidParam::set_payload_mass(double value) {
  set_has_payload_mass();
  payload_mass_ = value;
  // @@protoc_insertion_point(field_set:M3BaseHumanoidParam.payload_mass)
}

// repeated double payload_com = 2;
inline int M3BaseHumanoidParam::payload_com_size() const {
  return payload_com_.size();
}
inline void M3BaseHumanoidParam::clear_payload_com() {
  payload_com_.Clear();
}
inline double M3BaseHumanoidParam::payload_com(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidParam.payload_com)
  return payload_com_.Get(index);
}
inline void M3BaseHumanoidParam::set_payload_com(int index, double value) {
  payload_com_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidParam.payload_com)
}
inline void M3BaseHumanoidParam::add_payload_com(double value) {
  payload_com_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidParam.payload_com)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidParam::payload_com() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidParam.payload_com)
  return payload_com_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidParam::mutable_payload_com() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidParam.payload_com)
  return &payload_com_;
}

// repeated double payload_inertia = 3;
inline int M3BaseHumanoidParam::payload_inertia_size() const {
  return payload_inertia_.size();
}
inline void M3BaseHumanoidParam::clear_payload_inertia() {
  payload_inertia_.Clear();
}
inline double M3BaseHumanoidParam::payload_inertia(int index) const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidParam.payload_inertia)
  return payload_inertia_.Get(index);
}
inline void M3BaseHumanoidParam::set_payload_inertia(int index, double value) {
  payload_inertia_.Set(index, value);
  // @@protoc_insertion_point(field_set:M3BaseHumanoidParam.payload_inertia)
}
inline void M3BaseHumanoidParam::add_payload_inertia(double value) {
  payload_inertia_.Add(value);
  // @@protoc_insertion_point(field_add:M3BaseHumanoidParam.payload_inertia)
}
inline const ::google::protobuf::RepeatedField< double >&
M3BaseHumanoidParam::payload_inertia() const {
  // @@protoc_insertion_point(field_list:M3BaseHumanoidParam.payload_inertia)
  return payload_inertia_;
}
inline ::google::protobuf::RepeatedField< double >*
M3BaseHumanoidParam::mutable_payload_inertia() {
  // @@protoc_insertion_point(field_mutable_list:M3BaseHumanoidParam.payload_inertia)
  return &payload_inertia_;
}

// optional bool use_velocities = 4;
inline bool M3BaseHumanoidParam::has_use_velocities() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3BaseHumanoidParam::set_has_use_velocities() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3BaseHumanoidParam::clear_has_use_velocities() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3BaseHumanoidParam::clear_use_velocities() {
  use_velocities_ = false;
  clear_has_use_velocities();
}
inline bool M3BaseHumanoidParam::use_velocities() const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidParam.use_velocities)
  return use_velocities_;
}
inline void M3BaseHumanoidParam::set_use_velocities(bool value) {
  set_has_use_velocities();
  use_velocities_ = value;
  // @@protoc_insertion_point(field_set:M3BaseHumanoidParam.use_velocities)
}

// optional bool use_accelerations = 5;
inline bool M3BaseHumanoidParam::has_use_accelerations() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3BaseHumanoidParam::set_has_use_accelerations() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3BaseHumanoidParam::clear_has_use_accelerations() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3BaseHumanoidParam::clear_use_accelerations() {
  use_accelerations_ = false;
  clear_has_use_accelerations();
}
inline bool M3BaseHumanoidParam::use_accelerations() const {
  // @@protoc_insertion_point(field_get:M3BaseHumanoidParam.use_accelerations)
  return use_accelerations_;
}
inline void M3BaseHumanoidParam::set_use_accelerations(bool value) {
  set_has_use_accelerations();
  use_accelerations_ = value;
  // @@protoc_insertion_point(field_set:M3BaseHumanoidParam.use_accelerations)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_humanoid_2eproto__INCLUDED
