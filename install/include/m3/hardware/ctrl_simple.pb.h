// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ctrl_simple.proto

#ifndef PROTOBUF_ctrl_5fsimple_2eproto__INCLUDED
#define PROTOBUF_ctrl_5fsimple_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "component_base.pb.h"
#include "actuator.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ctrl_5fsimple_2eproto();
void protobuf_AssignDesc_ctrl_5fsimple_2eproto();
void protobuf_ShutdownFile_ctrl_5fsimple_2eproto();

class M3CtrlSimpleStatusCommand;
class M3CtrlSimpleStatus;
class M3ParamTrajectory;
class M3CtrlSimpleParam;
class M3ParamPID;
class M3CtrlSimpleCommand;

enum CTRL_SIMPLE_MODE {
  CTRL_MODE_OFF = 0,
  CTRL_MODE_CURRENT = 1,
  CTRL_MODE_TORQUE = 2,
  CTRL_MODE_TORQUE_GC = 3,
  CTRL_MODE_THETA = 4,
  CTRL_MODE_THETA_IMP = 5,
  CTRL_MODE_BRAKE = 6
};
bool CTRL_SIMPLE_MODE_IsValid(int value);
const CTRL_SIMPLE_MODE CTRL_SIMPLE_MODE_MIN = CTRL_MODE_OFF;
const CTRL_SIMPLE_MODE CTRL_SIMPLE_MODE_MAX = CTRL_MODE_BRAKE;
const int CTRL_SIMPLE_MODE_ARRAYSIZE = CTRL_SIMPLE_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CTRL_SIMPLE_MODE_descriptor();
inline const ::std::string& CTRL_SIMPLE_MODE_Name(CTRL_SIMPLE_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CTRL_SIMPLE_MODE_descriptor(), value);
}
inline bool CTRL_SIMPLE_MODE_Parse(
    const ::std::string& name, CTRL_SIMPLE_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CTRL_SIMPLE_MODE>(
    CTRL_SIMPLE_MODE_descriptor(), name, value);
}
enum CTRL_SIMPLE_TRAJ_MODE {
  TRAJ_OFF = 0,
  TRAJ_SQUARE = 1,
  TRAJ_SINE = 2
};
bool CTRL_SIMPLE_TRAJ_MODE_IsValid(int value);
const CTRL_SIMPLE_TRAJ_MODE CTRL_SIMPLE_TRAJ_MODE_MIN = TRAJ_OFF;
const CTRL_SIMPLE_TRAJ_MODE CTRL_SIMPLE_TRAJ_MODE_MAX = TRAJ_SINE;
const int CTRL_SIMPLE_TRAJ_MODE_ARRAYSIZE = CTRL_SIMPLE_TRAJ_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CTRL_SIMPLE_TRAJ_MODE_descriptor();
inline const ::std::string& CTRL_SIMPLE_TRAJ_MODE_Name(CTRL_SIMPLE_TRAJ_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CTRL_SIMPLE_TRAJ_MODE_descriptor(), value);
}
inline bool CTRL_SIMPLE_TRAJ_MODE_Parse(
    const ::std::string& name, CTRL_SIMPLE_TRAJ_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CTRL_SIMPLE_TRAJ_MODE>(
    CTRL_SIMPLE_TRAJ_MODE_descriptor(), name, value);
}
// ===================================================================

class M3CtrlSimpleStatusCommand : public ::google::protobuf::Message {
 public:
  M3CtrlSimpleStatusCommand();
  virtual ~M3CtrlSimpleStatusCommand();

  M3CtrlSimpleStatusCommand(const M3CtrlSimpleStatusCommand& from);

  inline M3CtrlSimpleStatusCommand& operator=(const M3CtrlSimpleStatusCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3CtrlSimpleStatusCommand& default_instance();

  void Swap(M3CtrlSimpleStatusCommand* other);

  // implements Message ----------------------------------------------

  M3CtrlSimpleStatusCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3CtrlSimpleStatusCommand& from);
  void MergeFrom(const M3CtrlSimpleStatusCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double theta = 1;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 1;
  inline double theta() const;
  inline void set_theta(double value);

  // optional double current = 2;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 2;
  inline double current() const;
  inline void set_current(double value);

  // optional double torque = 3;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 3;
  inline double torque() const;
  inline void set_torque(double value);

  // optional double stiffness = 4;
  inline bool has_stiffness() const;
  inline void clear_stiffness();
  static const int kStiffnessFieldNumber = 4;
  inline double stiffness() const;
  inline void set_stiffness(double value);

  // optional double pwm = 5;
  inline bool has_pwm() const;
  inline void clear_pwm();
  static const int kPwmFieldNumber = 5;
  inline double pwm() const;
  inline void set_pwm(double value);

  // @@protoc_insertion_point(class_scope:M3CtrlSimpleStatusCommand)
 private:
  inline void set_has_theta();
  inline void clear_has_theta();
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_stiffness();
  inline void clear_has_stiffness();
  inline void set_has_pwm();
  inline void clear_has_pwm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double theta_;
  double current_;
  double torque_;
  double stiffness_;
  double pwm_;
  friend void  protobuf_AddDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_AssignDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_ShutdownFile_ctrl_5fsimple_2eproto();

  void InitAsDefaultInstance();
  static M3CtrlSimpleStatusCommand* default_instance_;
};
// -------------------------------------------------------------------

class M3CtrlSimpleStatus : public ::google::protobuf::Message {
 public:
  M3CtrlSimpleStatus();
  virtual ~M3CtrlSimpleStatus();

  M3CtrlSimpleStatus(const M3CtrlSimpleStatus& from);

  inline M3CtrlSimpleStatus& operator=(const M3CtrlSimpleStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3CtrlSimpleStatus& default_instance();

  void Swap(M3CtrlSimpleStatus* other);

  // implements Message ----------------------------------------------

  M3CtrlSimpleStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3CtrlSimpleStatus& from);
  void MergeFrom(const M3CtrlSimpleStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .M3BaseStatus base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::M3BaseStatus& base() const;
  inline ::M3BaseStatus* mutable_base();
  inline ::M3BaseStatus* release_base();
  inline void set_allocated_base(::M3BaseStatus* base);

  // optional .M3CtrlSimpleStatusCommand command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::M3CtrlSimpleStatusCommand& command() const;
  inline ::M3CtrlSimpleStatusCommand* mutable_command();
  inline ::M3CtrlSimpleStatusCommand* release_command();
  inline void set_allocated_command(::M3CtrlSimpleStatusCommand* command);

  // optional .M3ActuatorStatus actuator = 3;
  inline bool has_actuator() const;
  inline void clear_actuator();
  static const int kActuatorFieldNumber = 3;
  inline const ::M3ActuatorStatus& actuator() const;
  inline ::M3ActuatorStatus* mutable_actuator();
  inline ::M3ActuatorStatus* release_actuator();
  inline void set_allocated_actuator(::M3ActuatorStatus* actuator);

  // optional double torque_gravity = 4;
  inline bool has_torque_gravity() const;
  inline void clear_torque_gravity();
  static const int kTorqueGravityFieldNumber = 4;
  inline double torque_gravity() const;
  inline void set_torque_gravity(double value);

  // @@protoc_insertion_point(class_scope:M3CtrlSimpleStatus)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_actuator();
  inline void clear_has_actuator();
  inline void set_has_torque_gravity();
  inline void clear_has_torque_gravity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::M3BaseStatus* base_;
  ::M3CtrlSimpleStatusCommand* command_;
  ::M3ActuatorStatus* actuator_;
  double torque_gravity_;
  friend void  protobuf_AddDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_AssignDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_ShutdownFile_ctrl_5fsimple_2eproto();

  void InitAsDefaultInstance();
  static M3CtrlSimpleStatus* default_instance_;
};
// -------------------------------------------------------------------

class M3ParamTrajectory : public ::google::protobuf::Message {
 public:
  M3ParamTrajectory();
  virtual ~M3ParamTrajectory();

  M3ParamTrajectory(const M3ParamTrajectory& from);

  inline M3ParamTrajectory& operator=(const M3ParamTrajectory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ParamTrajectory& default_instance();

  void Swap(M3ParamTrajectory* other);

  // implements Message ----------------------------------------------

  M3ParamTrajectory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ParamTrajectory& from);
  void MergeFrom(const M3ParamTrajectory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double freq = 1;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 1;
  inline double freq() const;
  inline void set_freq(double value);

  // optional double amp = 2;
  inline bool has_amp() const;
  inline void clear_amp();
  static const int kAmpFieldNumber = 2;
  inline double amp() const;
  inline void set_amp(double value);

  // optional double zero = 3;
  inline bool has_zero() const;
  inline void clear_zero();
  static const int kZeroFieldNumber = 3;
  inline double zero() const;
  inline void set_zero(double value);

  // @@protoc_insertion_point(class_scope:M3ParamTrajectory)
 private:
  inline void set_has_freq();
  inline void clear_has_freq();
  inline void set_has_amp();
  inline void clear_has_amp();
  inline void set_has_zero();
  inline void clear_has_zero();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double freq_;
  double amp_;
  double zero_;
  friend void  protobuf_AddDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_AssignDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_ShutdownFile_ctrl_5fsimple_2eproto();

  void InitAsDefaultInstance();
  static M3ParamTrajectory* default_instance_;
};
// -------------------------------------------------------------------

class M3CtrlSimpleParam : public ::google::protobuf::Message {
 public:
  M3CtrlSimpleParam();
  virtual ~M3CtrlSimpleParam();

  M3CtrlSimpleParam(const M3CtrlSimpleParam& from);

  inline M3CtrlSimpleParam& operator=(const M3CtrlSimpleParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3CtrlSimpleParam& default_instance();

  void Swap(M3CtrlSimpleParam* other);

  // implements Message ----------------------------------------------

  M3CtrlSimpleParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3CtrlSimpleParam& from);
  void MergeFrom(const M3CtrlSimpleParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .M3ParamTrajectory traj_current = 1;
  inline bool has_traj_current() const;
  inline void clear_traj_current();
  static const int kTrajCurrentFieldNumber = 1;
  inline const ::M3ParamTrajectory& traj_current() const;
  inline ::M3ParamTrajectory* mutable_traj_current();
  inline ::M3ParamTrajectory* release_traj_current();
  inline void set_allocated_traj_current(::M3ParamTrajectory* traj_current);

  // optional .M3ParamTrajectory traj_torque = 2;
  inline bool has_traj_torque() const;
  inline void clear_traj_torque();
  static const int kTrajTorqueFieldNumber = 2;
  inline const ::M3ParamTrajectory& traj_torque() const;
  inline ::M3ParamTrajectory* mutable_traj_torque();
  inline ::M3ParamTrajectory* release_traj_torque();
  inline void set_allocated_traj_torque(::M3ParamTrajectory* traj_torque);

  // optional .M3ParamTrajectory traj_theta = 3;
  inline bool has_traj_theta() const;
  inline void clear_traj_theta();
  static const int kTrajThetaFieldNumber = 3;
  inline const ::M3ParamTrajectory& traj_theta() const;
  inline ::M3ParamTrajectory* mutable_traj_theta();
  inline ::M3ParamTrajectory* release_traj_theta();
  inline void set_allocated_traj_theta(::M3ParamTrajectory* traj_theta);

  // optional .M3ParamPID pid_theta = 4;
  inline bool has_pid_theta() const;
  inline void clear_pid_theta();
  static const int kPidThetaFieldNumber = 4;
  inline const ::M3ParamPID& pid_theta() const;
  inline ::M3ParamPID* mutable_pid_theta();
  inline ::M3ParamPID* release_pid_theta();
  inline void set_allocated_pid_theta(::M3ParamPID* pid_theta);

  // optional .M3ParamPID pid_torque = 5;
  inline bool has_pid_torque() const;
  inline void clear_pid_torque();
  static const int kPidTorqueFieldNumber = 5;
  inline const ::M3ParamPID& pid_torque() const;
  inline ::M3ParamPID* mutable_pid_torque();
  inline ::M3ParamPID* release_pid_torque();
  inline void set_allocated_pid_torque(::M3ParamPID* pid_torque);

  // @@protoc_insertion_point(class_scope:M3CtrlSimpleParam)
 private:
  inline void set_has_traj_current();
  inline void clear_has_traj_current();
  inline void set_has_traj_torque();
  inline void clear_has_traj_torque();
  inline void set_has_traj_theta();
  inline void clear_has_traj_theta();
  inline void set_has_pid_theta();
  inline void clear_has_pid_theta();
  inline void set_has_pid_torque();
  inline void clear_has_pid_torque();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::M3ParamTrajectory* traj_current_;
  ::M3ParamTrajectory* traj_torque_;
  ::M3ParamTrajectory* traj_theta_;
  ::M3ParamPID* pid_theta_;
  ::M3ParamPID* pid_torque_;
  friend void  protobuf_AddDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_AssignDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_ShutdownFile_ctrl_5fsimple_2eproto();

  void InitAsDefaultInstance();
  static M3CtrlSimpleParam* default_instance_;
};
// -------------------------------------------------------------------

class M3ParamPID : public ::google::protobuf::Message {
 public:
  M3ParamPID();
  virtual ~M3ParamPID();

  M3ParamPID(const M3ParamPID& from);

  inline M3ParamPID& operator=(const M3ParamPID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ParamPID& default_instance();

  void Swap(M3ParamPID* other);

  // implements Message ----------------------------------------------

  M3ParamPID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ParamPID& from);
  void MergeFrom(const M3ParamPID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double k_p = 1;
  inline bool has_k_p() const;
  inline void clear_k_p();
  static const int kKPFieldNumber = 1;
  inline double k_p() const;
  inline void set_k_p(double value);

  // optional double k_i = 2;
  inline bool has_k_i() const;
  inline void clear_k_i();
  static const int kKIFieldNumber = 2;
  inline double k_i() const;
  inline void set_k_i(double value);

  // optional double k_d = 3;
  inline bool has_k_d() const;
  inline void clear_k_d();
  static const int kKDFieldNumber = 3;
  inline double k_d() const;
  inline void set_k_d(double value);

  // optional double k_i_limit = 4;
  inline bool has_k_i_limit() const;
  inline void clear_k_i_limit();
  static const int kKILimitFieldNumber = 4;
  inline double k_i_limit() const;
  inline void set_k_i_limit(double value);

  // optional double k_i_range = 5;
  inline bool has_k_i_range() const;
  inline void clear_k_i_range();
  static const int kKIRangeFieldNumber = 5;
  inline double k_i_range() const;
  inline void set_k_i_range(double value);

  // @@protoc_insertion_point(class_scope:M3ParamPID)
 private:
  inline void set_has_k_p();
  inline void clear_has_k_p();
  inline void set_has_k_i();
  inline void clear_has_k_i();
  inline void set_has_k_d();
  inline void clear_has_k_d();
  inline void set_has_k_i_limit();
  inline void clear_has_k_i_limit();
  inline void set_has_k_i_range();
  inline void clear_has_k_i_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double k_p_;
  double k_i_;
  double k_d_;
  double k_i_limit_;
  double k_i_range_;
  friend void  protobuf_AddDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_AssignDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_ShutdownFile_ctrl_5fsimple_2eproto();

  void InitAsDefaultInstance();
  static M3ParamPID* default_instance_;
};
// -------------------------------------------------------------------

class M3CtrlSimpleCommand : public ::google::protobuf::Message {
 public:
  M3CtrlSimpleCommand();
  virtual ~M3CtrlSimpleCommand();

  M3CtrlSimpleCommand(const M3CtrlSimpleCommand& from);

  inline M3CtrlSimpleCommand& operator=(const M3CtrlSimpleCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3CtrlSimpleCommand& default_instance();

  void Swap(M3CtrlSimpleCommand* other);

  // implements Message ----------------------------------------------

  M3CtrlSimpleCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3CtrlSimpleCommand& from);
  void MergeFrom(const M3CtrlSimpleCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CTRL_SIMPLE_MODE ctrl_mode = 1;
  inline bool has_ctrl_mode() const;
  inline void clear_ctrl_mode();
  static const int kCtrlModeFieldNumber = 1;
  inline ::CTRL_SIMPLE_MODE ctrl_mode() const;
  inline void set_ctrl_mode(::CTRL_SIMPLE_MODE value);

  // optional .CTRL_SIMPLE_TRAJ_MODE traj_mode = 2;
  inline bool has_traj_mode() const;
  inline void clear_traj_mode();
  static const int kTrajModeFieldNumber = 2;
  inline ::CTRL_SIMPLE_TRAJ_MODE traj_mode() const;
  inline void set_traj_mode(::CTRL_SIMPLE_TRAJ_MODE value);

  // optional double desired_current = 3;
  inline bool has_desired_current() const;
  inline void clear_desired_current();
  static const int kDesiredCurrentFieldNumber = 3;
  inline double desired_current() const;
  inline void set_desired_current(double value);

  // optional double desired_theta = 4;
  inline bool has_desired_theta() const;
  inline void clear_desired_theta();
  static const int kDesiredThetaFieldNumber = 4;
  inline double desired_theta() const;
  inline void set_desired_theta(double value);

  // optional double desired_torque = 5;
  inline bool has_desired_torque() const;
  inline void clear_desired_torque();
  static const int kDesiredTorqueFieldNumber = 5;
  inline double desired_torque() const;
  inline void set_desired_torque(double value);

  // optional double desired_stiffness = 6;
  inline bool has_desired_stiffness() const;
  inline void clear_desired_stiffness();
  static const int kDesiredStiffnessFieldNumber = 6;
  inline double desired_stiffness() const;
  inline void set_desired_stiffness(double value);

  // @@protoc_insertion_point(class_scope:M3CtrlSimpleCommand)
 private:
  inline void set_has_ctrl_mode();
  inline void clear_has_ctrl_mode();
  inline void set_has_traj_mode();
  inline void clear_has_traj_mode();
  inline void set_has_desired_current();
  inline void clear_has_desired_current();
  inline void set_has_desired_theta();
  inline void clear_has_desired_theta();
  inline void set_has_desired_torque();
  inline void clear_has_desired_torque();
  inline void set_has_desired_stiffness();
  inline void clear_has_desired_stiffness();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int ctrl_mode_;
  int traj_mode_;
  double desired_current_;
  double desired_theta_;
  double desired_torque_;
  double desired_stiffness_;
  friend void  protobuf_AddDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_AssignDesc_ctrl_5fsimple_2eproto();
  friend void protobuf_ShutdownFile_ctrl_5fsimple_2eproto();

  void InitAsDefaultInstance();
  static M3CtrlSimpleCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// M3CtrlSimpleStatusCommand

// optional double theta = 1;
inline bool M3CtrlSimpleStatusCommand::has_theta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3CtrlSimpleStatusCommand::set_has_theta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3CtrlSimpleStatusCommand::clear_has_theta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3CtrlSimpleStatusCommand::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double M3CtrlSimpleStatusCommand::theta() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatusCommand.theta)
  return theta_;
}
inline void M3CtrlSimpleStatusCommand::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleStatusCommand.theta)
}

// optional double current = 2;
inline bool M3CtrlSimpleStatusCommand::has_current() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3CtrlSimpleStatusCommand::set_has_current() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3CtrlSimpleStatusCommand::clear_has_current() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3CtrlSimpleStatusCommand::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline double M3CtrlSimpleStatusCommand::current() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatusCommand.current)
  return current_;
}
inline void M3CtrlSimpleStatusCommand::set_current(double value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleStatusCommand.current)
}

// optional double torque = 3;
inline bool M3CtrlSimpleStatusCommand::has_torque() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3CtrlSimpleStatusCommand::set_has_torque() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3CtrlSimpleStatusCommand::clear_has_torque() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3CtrlSimpleStatusCommand::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline double M3CtrlSimpleStatusCommand::torque() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatusCommand.torque)
  return torque_;
}
inline void M3CtrlSimpleStatusCommand::set_torque(double value) {
  set_has_torque();
  torque_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleStatusCommand.torque)
}

// optional double stiffness = 4;
inline bool M3CtrlSimpleStatusCommand::has_stiffness() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3CtrlSimpleStatusCommand::set_has_stiffness() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3CtrlSimpleStatusCommand::clear_has_stiffness() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3CtrlSimpleStatusCommand::clear_stiffness() {
  stiffness_ = 0;
  clear_has_stiffness();
}
inline double M3CtrlSimpleStatusCommand::stiffness() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatusCommand.stiffness)
  return stiffness_;
}
inline void M3CtrlSimpleStatusCommand::set_stiffness(double value) {
  set_has_stiffness();
  stiffness_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleStatusCommand.stiffness)
}

// optional double pwm = 5;
inline bool M3CtrlSimpleStatusCommand::has_pwm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3CtrlSimpleStatusCommand::set_has_pwm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3CtrlSimpleStatusCommand::clear_has_pwm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3CtrlSimpleStatusCommand::clear_pwm() {
  pwm_ = 0;
  clear_has_pwm();
}
inline double M3CtrlSimpleStatusCommand::pwm() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatusCommand.pwm)
  return pwm_;
}
inline void M3CtrlSimpleStatusCommand::set_pwm(double value) {
  set_has_pwm();
  pwm_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleStatusCommand.pwm)
}

// -------------------------------------------------------------------

// M3CtrlSimpleStatus

// optional .M3BaseStatus base = 1;
inline bool M3CtrlSimpleStatus::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3CtrlSimpleStatus::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3CtrlSimpleStatus::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3CtrlSimpleStatus::clear_base() {
  if (base_ != NULL) base_->::M3BaseStatus::Clear();
  clear_has_base();
}
inline const ::M3BaseStatus& M3CtrlSimpleStatus::base() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatus.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::M3BaseStatus* M3CtrlSimpleStatus::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::M3BaseStatus;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleStatus.base)
  return base_;
}
inline ::M3BaseStatus* M3CtrlSimpleStatus::release_base() {
  clear_has_base();
  ::M3BaseStatus* temp = base_;
  base_ = NULL;
  return temp;
}
inline void M3CtrlSimpleStatus::set_allocated_base(::M3BaseStatus* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleStatus.base)
}

// optional .M3CtrlSimpleStatusCommand command = 2;
inline bool M3CtrlSimpleStatus::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3CtrlSimpleStatus::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3CtrlSimpleStatus::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3CtrlSimpleStatus::clear_command() {
  if (command_ != NULL) command_->::M3CtrlSimpleStatusCommand::Clear();
  clear_has_command();
}
inline const ::M3CtrlSimpleStatusCommand& M3CtrlSimpleStatus::command() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatus.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::M3CtrlSimpleStatusCommand* M3CtrlSimpleStatus::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::M3CtrlSimpleStatusCommand;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleStatus.command)
  return command_;
}
inline ::M3CtrlSimpleStatusCommand* M3CtrlSimpleStatus::release_command() {
  clear_has_command();
  ::M3CtrlSimpleStatusCommand* temp = command_;
  command_ = NULL;
  return temp;
}
inline void M3CtrlSimpleStatus::set_allocated_command(::M3CtrlSimpleStatusCommand* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleStatus.command)
}

// optional .M3ActuatorStatus actuator = 3;
inline bool M3CtrlSimpleStatus::has_actuator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3CtrlSimpleStatus::set_has_actuator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3CtrlSimpleStatus::clear_has_actuator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3CtrlSimpleStatus::clear_actuator() {
  if (actuator_ != NULL) actuator_->::M3ActuatorStatus::Clear();
  clear_has_actuator();
}
inline const ::M3ActuatorStatus& M3CtrlSimpleStatus::actuator() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatus.actuator)
  return actuator_ != NULL ? *actuator_ : *default_instance_->actuator_;
}
inline ::M3ActuatorStatus* M3CtrlSimpleStatus::mutable_actuator() {
  set_has_actuator();
  if (actuator_ == NULL) actuator_ = new ::M3ActuatorStatus;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleStatus.actuator)
  return actuator_;
}
inline ::M3ActuatorStatus* M3CtrlSimpleStatus::release_actuator() {
  clear_has_actuator();
  ::M3ActuatorStatus* temp = actuator_;
  actuator_ = NULL;
  return temp;
}
inline void M3CtrlSimpleStatus::set_allocated_actuator(::M3ActuatorStatus* actuator) {
  delete actuator_;
  actuator_ = actuator;
  if (actuator) {
    set_has_actuator();
  } else {
    clear_has_actuator();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleStatus.actuator)
}

// optional double torque_gravity = 4;
inline bool M3CtrlSimpleStatus::has_torque_gravity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3CtrlSimpleStatus::set_has_torque_gravity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3CtrlSimpleStatus::clear_has_torque_gravity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3CtrlSimpleStatus::clear_torque_gravity() {
  torque_gravity_ = 0;
  clear_has_torque_gravity();
}
inline double M3CtrlSimpleStatus::torque_gravity() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleStatus.torque_gravity)
  return torque_gravity_;
}
inline void M3CtrlSimpleStatus::set_torque_gravity(double value) {
  set_has_torque_gravity();
  torque_gravity_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleStatus.torque_gravity)
}

// -------------------------------------------------------------------

// M3ParamTrajectory

// optional double freq = 1;
inline bool M3ParamTrajectory::has_freq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ParamTrajectory::set_has_freq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ParamTrajectory::clear_has_freq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ParamTrajectory::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline double M3ParamTrajectory::freq() const {
  // @@protoc_insertion_point(field_get:M3ParamTrajectory.freq)
  return freq_;
}
inline void M3ParamTrajectory::set_freq(double value) {
  set_has_freq();
  freq_ = value;
  // @@protoc_insertion_point(field_set:M3ParamTrajectory.freq)
}

// optional double amp = 2;
inline bool M3ParamTrajectory::has_amp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ParamTrajectory::set_has_amp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ParamTrajectory::clear_has_amp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ParamTrajectory::clear_amp() {
  amp_ = 0;
  clear_has_amp();
}
inline double M3ParamTrajectory::amp() const {
  // @@protoc_insertion_point(field_get:M3ParamTrajectory.amp)
  return amp_;
}
inline void M3ParamTrajectory::set_amp(double value) {
  set_has_amp();
  amp_ = value;
  // @@protoc_insertion_point(field_set:M3ParamTrajectory.amp)
}

// optional double zero = 3;
inline bool M3ParamTrajectory::has_zero() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ParamTrajectory::set_has_zero() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ParamTrajectory::clear_has_zero() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ParamTrajectory::clear_zero() {
  zero_ = 0;
  clear_has_zero();
}
inline double M3ParamTrajectory::zero() const {
  // @@protoc_insertion_point(field_get:M3ParamTrajectory.zero)
  return zero_;
}
inline void M3ParamTrajectory::set_zero(double value) {
  set_has_zero();
  zero_ = value;
  // @@protoc_insertion_point(field_set:M3ParamTrajectory.zero)
}

// -------------------------------------------------------------------

// M3CtrlSimpleParam

// optional .M3ParamTrajectory traj_current = 1;
inline bool M3CtrlSimpleParam::has_traj_current() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3CtrlSimpleParam::set_has_traj_current() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3CtrlSimpleParam::clear_has_traj_current() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3CtrlSimpleParam::clear_traj_current() {
  if (traj_current_ != NULL) traj_current_->::M3ParamTrajectory::Clear();
  clear_has_traj_current();
}
inline const ::M3ParamTrajectory& M3CtrlSimpleParam::traj_current() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleParam.traj_current)
  return traj_current_ != NULL ? *traj_current_ : *default_instance_->traj_current_;
}
inline ::M3ParamTrajectory* M3CtrlSimpleParam::mutable_traj_current() {
  set_has_traj_current();
  if (traj_current_ == NULL) traj_current_ = new ::M3ParamTrajectory;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleParam.traj_current)
  return traj_current_;
}
inline ::M3ParamTrajectory* M3CtrlSimpleParam::release_traj_current() {
  clear_has_traj_current();
  ::M3ParamTrajectory* temp = traj_current_;
  traj_current_ = NULL;
  return temp;
}
inline void M3CtrlSimpleParam::set_allocated_traj_current(::M3ParamTrajectory* traj_current) {
  delete traj_current_;
  traj_current_ = traj_current;
  if (traj_current) {
    set_has_traj_current();
  } else {
    clear_has_traj_current();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleParam.traj_current)
}

// optional .M3ParamTrajectory traj_torque = 2;
inline bool M3CtrlSimpleParam::has_traj_torque() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3CtrlSimpleParam::set_has_traj_torque() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3CtrlSimpleParam::clear_has_traj_torque() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3CtrlSimpleParam::clear_traj_torque() {
  if (traj_torque_ != NULL) traj_torque_->::M3ParamTrajectory::Clear();
  clear_has_traj_torque();
}
inline const ::M3ParamTrajectory& M3CtrlSimpleParam::traj_torque() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleParam.traj_torque)
  return traj_torque_ != NULL ? *traj_torque_ : *default_instance_->traj_torque_;
}
inline ::M3ParamTrajectory* M3CtrlSimpleParam::mutable_traj_torque() {
  set_has_traj_torque();
  if (traj_torque_ == NULL) traj_torque_ = new ::M3ParamTrajectory;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleParam.traj_torque)
  return traj_torque_;
}
inline ::M3ParamTrajectory* M3CtrlSimpleParam::release_traj_torque() {
  clear_has_traj_torque();
  ::M3ParamTrajectory* temp = traj_torque_;
  traj_torque_ = NULL;
  return temp;
}
inline void M3CtrlSimpleParam::set_allocated_traj_torque(::M3ParamTrajectory* traj_torque) {
  delete traj_torque_;
  traj_torque_ = traj_torque;
  if (traj_torque) {
    set_has_traj_torque();
  } else {
    clear_has_traj_torque();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleParam.traj_torque)
}

// optional .M3ParamTrajectory traj_theta = 3;
inline bool M3CtrlSimpleParam::has_traj_theta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3CtrlSimpleParam::set_has_traj_theta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3CtrlSimpleParam::clear_has_traj_theta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3CtrlSimpleParam::clear_traj_theta() {
  if (traj_theta_ != NULL) traj_theta_->::M3ParamTrajectory::Clear();
  clear_has_traj_theta();
}
inline const ::M3ParamTrajectory& M3CtrlSimpleParam::traj_theta() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleParam.traj_theta)
  return traj_theta_ != NULL ? *traj_theta_ : *default_instance_->traj_theta_;
}
inline ::M3ParamTrajectory* M3CtrlSimpleParam::mutable_traj_theta() {
  set_has_traj_theta();
  if (traj_theta_ == NULL) traj_theta_ = new ::M3ParamTrajectory;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleParam.traj_theta)
  return traj_theta_;
}
inline ::M3ParamTrajectory* M3CtrlSimpleParam::release_traj_theta() {
  clear_has_traj_theta();
  ::M3ParamTrajectory* temp = traj_theta_;
  traj_theta_ = NULL;
  return temp;
}
inline void M3CtrlSimpleParam::set_allocated_traj_theta(::M3ParamTrajectory* traj_theta) {
  delete traj_theta_;
  traj_theta_ = traj_theta;
  if (traj_theta) {
    set_has_traj_theta();
  } else {
    clear_has_traj_theta();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleParam.traj_theta)
}

// optional .M3ParamPID pid_theta = 4;
inline bool M3CtrlSimpleParam::has_pid_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3CtrlSimpleParam::set_has_pid_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3CtrlSimpleParam::clear_has_pid_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3CtrlSimpleParam::clear_pid_theta() {
  if (pid_theta_ != NULL) pid_theta_->::M3ParamPID::Clear();
  clear_has_pid_theta();
}
inline const ::M3ParamPID& M3CtrlSimpleParam::pid_theta() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleParam.pid_theta)
  return pid_theta_ != NULL ? *pid_theta_ : *default_instance_->pid_theta_;
}
inline ::M3ParamPID* M3CtrlSimpleParam::mutable_pid_theta() {
  set_has_pid_theta();
  if (pid_theta_ == NULL) pid_theta_ = new ::M3ParamPID;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleParam.pid_theta)
  return pid_theta_;
}
inline ::M3ParamPID* M3CtrlSimpleParam::release_pid_theta() {
  clear_has_pid_theta();
  ::M3ParamPID* temp = pid_theta_;
  pid_theta_ = NULL;
  return temp;
}
inline void M3CtrlSimpleParam::set_allocated_pid_theta(::M3ParamPID* pid_theta) {
  delete pid_theta_;
  pid_theta_ = pid_theta;
  if (pid_theta) {
    set_has_pid_theta();
  } else {
    clear_has_pid_theta();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleParam.pid_theta)
}

// optional .M3ParamPID pid_torque = 5;
inline bool M3CtrlSimpleParam::has_pid_torque() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3CtrlSimpleParam::set_has_pid_torque() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3CtrlSimpleParam::clear_has_pid_torque() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3CtrlSimpleParam::clear_pid_torque() {
  if (pid_torque_ != NULL) pid_torque_->::M3ParamPID::Clear();
  clear_has_pid_torque();
}
inline const ::M3ParamPID& M3CtrlSimpleParam::pid_torque() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleParam.pid_torque)
  return pid_torque_ != NULL ? *pid_torque_ : *default_instance_->pid_torque_;
}
inline ::M3ParamPID* M3CtrlSimpleParam::mutable_pid_torque() {
  set_has_pid_torque();
  if (pid_torque_ == NULL) pid_torque_ = new ::M3ParamPID;
  // @@protoc_insertion_point(field_mutable:M3CtrlSimpleParam.pid_torque)
  return pid_torque_;
}
inline ::M3ParamPID* M3CtrlSimpleParam::release_pid_torque() {
  clear_has_pid_torque();
  ::M3ParamPID* temp = pid_torque_;
  pid_torque_ = NULL;
  return temp;
}
inline void M3CtrlSimpleParam::set_allocated_pid_torque(::M3ParamPID* pid_torque) {
  delete pid_torque_;
  pid_torque_ = pid_torque;
  if (pid_torque) {
    set_has_pid_torque();
  } else {
    clear_has_pid_torque();
  }
  // @@protoc_insertion_point(field_set_allocated:M3CtrlSimpleParam.pid_torque)
}

// -------------------------------------------------------------------

// M3ParamPID

// optional double k_p = 1;
inline bool M3ParamPID::has_k_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ParamPID::set_has_k_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ParamPID::clear_has_k_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ParamPID::clear_k_p() {
  k_p_ = 0;
  clear_has_k_p();
}
inline double M3ParamPID::k_p() const {
  // @@protoc_insertion_point(field_get:M3ParamPID.k_p)
  return k_p_;
}
inline void M3ParamPID::set_k_p(double value) {
  set_has_k_p();
  k_p_ = value;
  // @@protoc_insertion_point(field_set:M3ParamPID.k_p)
}

// optional double k_i = 2;
inline bool M3ParamPID::has_k_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ParamPID::set_has_k_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ParamPID::clear_has_k_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ParamPID::clear_k_i() {
  k_i_ = 0;
  clear_has_k_i();
}
inline double M3ParamPID::k_i() const {
  // @@protoc_insertion_point(field_get:M3ParamPID.k_i)
  return k_i_;
}
inline void M3ParamPID::set_k_i(double value) {
  set_has_k_i();
  k_i_ = value;
  // @@protoc_insertion_point(field_set:M3ParamPID.k_i)
}

// optional double k_d = 3;
inline bool M3ParamPID::has_k_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ParamPID::set_has_k_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ParamPID::clear_has_k_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ParamPID::clear_k_d() {
  k_d_ = 0;
  clear_has_k_d();
}
inline double M3ParamPID::k_d() const {
  // @@protoc_insertion_point(field_get:M3ParamPID.k_d)
  return k_d_;
}
inline void M3ParamPID::set_k_d(double value) {
  set_has_k_d();
  k_d_ = value;
  // @@protoc_insertion_point(field_set:M3ParamPID.k_d)
}

// optional double k_i_limit = 4;
inline bool M3ParamPID::has_k_i_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ParamPID::set_has_k_i_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ParamPID::clear_has_k_i_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ParamPID::clear_k_i_limit() {
  k_i_limit_ = 0;
  clear_has_k_i_limit();
}
inline double M3ParamPID::k_i_limit() const {
  // @@protoc_insertion_point(field_get:M3ParamPID.k_i_limit)
  return k_i_limit_;
}
inline void M3ParamPID::set_k_i_limit(double value) {
  set_has_k_i_limit();
  k_i_limit_ = value;
  // @@protoc_insertion_point(field_set:M3ParamPID.k_i_limit)
}

// optional double k_i_range = 5;
inline bool M3ParamPID::has_k_i_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ParamPID::set_has_k_i_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ParamPID::clear_has_k_i_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ParamPID::clear_k_i_range() {
  k_i_range_ = 0;
  clear_has_k_i_range();
}
inline double M3ParamPID::k_i_range() const {
  // @@protoc_insertion_point(field_get:M3ParamPID.k_i_range)
  return k_i_range_;
}
inline void M3ParamPID::set_k_i_range(double value) {
  set_has_k_i_range();
  k_i_range_ = value;
  // @@protoc_insertion_point(field_set:M3ParamPID.k_i_range)
}

// -------------------------------------------------------------------

// M3CtrlSimpleCommand

// optional .CTRL_SIMPLE_MODE ctrl_mode = 1;
inline bool M3CtrlSimpleCommand::has_ctrl_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3CtrlSimpleCommand::set_has_ctrl_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3CtrlSimpleCommand::clear_has_ctrl_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3CtrlSimpleCommand::clear_ctrl_mode() {
  ctrl_mode_ = 0;
  clear_has_ctrl_mode();
}
inline ::CTRL_SIMPLE_MODE M3CtrlSimpleCommand::ctrl_mode() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleCommand.ctrl_mode)
  return static_cast< ::CTRL_SIMPLE_MODE >(ctrl_mode_);
}
inline void M3CtrlSimpleCommand::set_ctrl_mode(::CTRL_SIMPLE_MODE value) {
  assert(::CTRL_SIMPLE_MODE_IsValid(value));
  set_has_ctrl_mode();
  ctrl_mode_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleCommand.ctrl_mode)
}

// optional .CTRL_SIMPLE_TRAJ_MODE traj_mode = 2;
inline bool M3CtrlSimpleCommand::has_traj_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3CtrlSimpleCommand::set_has_traj_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3CtrlSimpleCommand::clear_has_traj_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3CtrlSimpleCommand::clear_traj_mode() {
  traj_mode_ = 0;
  clear_has_traj_mode();
}
inline ::CTRL_SIMPLE_TRAJ_MODE M3CtrlSimpleCommand::traj_mode() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleCommand.traj_mode)
  return static_cast< ::CTRL_SIMPLE_TRAJ_MODE >(traj_mode_);
}
inline void M3CtrlSimpleCommand::set_traj_mode(::CTRL_SIMPLE_TRAJ_MODE value) {
  assert(::CTRL_SIMPLE_TRAJ_MODE_IsValid(value));
  set_has_traj_mode();
  traj_mode_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleCommand.traj_mode)
}

// optional double desired_current = 3;
inline bool M3CtrlSimpleCommand::has_desired_current() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3CtrlSimpleCommand::set_has_desired_current() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3CtrlSimpleCommand::clear_has_desired_current() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3CtrlSimpleCommand::clear_desired_current() {
  desired_current_ = 0;
  clear_has_desired_current();
}
inline double M3CtrlSimpleCommand::desired_current() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleCommand.desired_current)
  return desired_current_;
}
inline void M3CtrlSimpleCommand::set_desired_current(double value) {
  set_has_desired_current();
  desired_current_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleCommand.desired_current)
}

// optional double desired_theta = 4;
inline bool M3CtrlSimpleCommand::has_desired_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3CtrlSimpleCommand::set_has_desired_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3CtrlSimpleCommand::clear_has_desired_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3CtrlSimpleCommand::clear_desired_theta() {
  desired_theta_ = 0;
  clear_has_desired_theta();
}
inline double M3CtrlSimpleCommand::desired_theta() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleCommand.desired_theta)
  return desired_theta_;
}
inline void M3CtrlSimpleCommand::set_desired_theta(double value) {
  set_has_desired_theta();
  desired_theta_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleCommand.desired_theta)
}

// optional double desired_torque = 5;
inline bool M3CtrlSimpleCommand::has_desired_torque() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3CtrlSimpleCommand::set_has_desired_torque() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3CtrlSimpleCommand::clear_has_desired_torque() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3CtrlSimpleCommand::clear_desired_torque() {
  desired_torque_ = 0;
  clear_has_desired_torque();
}
inline double M3CtrlSimpleCommand::desired_torque() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleCommand.desired_torque)
  return desired_torque_;
}
inline void M3CtrlSimpleCommand::set_desired_torque(double value) {
  set_has_desired_torque();
  desired_torque_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleCommand.desired_torque)
}

// optional double desired_stiffness = 6;
inline bool M3CtrlSimpleCommand::has_desired_stiffness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3CtrlSimpleCommand::set_has_desired_stiffness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3CtrlSimpleCommand::clear_has_desired_stiffness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3CtrlSimpleCommand::clear_desired_stiffness() {
  desired_stiffness_ = 0;
  clear_has_desired_stiffness();
}
inline double M3CtrlSimpleCommand::desired_stiffness() const {
  // @@protoc_insertion_point(field_get:M3CtrlSimpleCommand.desired_stiffness)
  return desired_stiffness_;
}
inline void M3CtrlSimpleCommand::set_desired_stiffness(double value) {
  set_has_desired_stiffness();
  desired_stiffness_ = value;
  // @@protoc_insertion_point(field_set:M3CtrlSimpleCommand.desired_stiffness)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CTRL_SIMPLE_MODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CTRL_SIMPLE_MODE>() {
  return ::CTRL_SIMPLE_MODE_descriptor();
}
template <> struct is_proto_enum< ::CTRL_SIMPLE_TRAJ_MODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CTRL_SIMPLE_TRAJ_MODE>() {
  return ::CTRL_SIMPLE_TRAJ_MODE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ctrl_5fsimple_2eproto__INCLUDED
