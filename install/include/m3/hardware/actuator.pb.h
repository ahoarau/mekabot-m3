// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: actuator.proto

#ifndef PROTOBUF_actuator_2eproto__INCLUDED
#define PROTOBUF_actuator_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "component_base.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_actuator_2eproto();
void protobuf_AssignDesc_actuator_2eproto();
void protobuf_ShutdownFile_actuator_2eproto();

class M3ActuatorStatus;
class M3ActuatorParamFilter;
class M3ActuatorParamPID;
class M3ActuatorParamAngleDf;
class M3ActuatorParam;
class M3ActuatorCommand;

enum ACTUATOR_MODE {
  ACTUATOR_MODE_OFF = 0,
  ACTUATOR_MODE_PWM = 1,
  ACTUATOR_MODE_TORQUE = 2,
  ACTUATOR_MODE_CURRENT = 3,
  ACTUATOR_MODE_BRAKE = 4
};
bool ACTUATOR_MODE_IsValid(int value);
const ACTUATOR_MODE ACTUATOR_MODE_MIN = ACTUATOR_MODE_OFF;
const ACTUATOR_MODE ACTUATOR_MODE_MAX = ACTUATOR_MODE_BRAKE;
const int ACTUATOR_MODE_ARRAYSIZE = ACTUATOR_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACTUATOR_MODE_descriptor();
inline const ::std::string& ACTUATOR_MODE_Name(ACTUATOR_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_MODE_descriptor(), value);
}
inline bool ACTUATOR_MODE_Parse(
    const ::std::string& name, ACTUATOR_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_MODE>(
    ACTUATOR_MODE_descriptor(), name, value);
}
enum ACTUATOR_INPUT {
  ACTUATOR_INPUT_PWM = 0,
  ACTUATOR_INPUT_CURRENT = 1
};
bool ACTUATOR_INPUT_IsValid(int value);
const ACTUATOR_INPUT ACTUATOR_INPUT_MIN = ACTUATOR_INPUT_PWM;
const ACTUATOR_INPUT ACTUATOR_INPUT_MAX = ACTUATOR_INPUT_CURRENT;
const int ACTUATOR_INPUT_ARRAYSIZE = ACTUATOR_INPUT_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACTUATOR_INPUT_descriptor();
inline const ::std::string& ACTUATOR_INPUT_Name(ACTUATOR_INPUT value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_INPUT_descriptor(), value);
}
inline bool ACTUATOR_INPUT_Parse(
    const ::std::string& name, ACTUATOR_INPUT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_INPUT>(
    ACTUATOR_INPUT_descriptor(), name, value);
}
// ===================================================================

class M3ActuatorStatus : public ::google::protobuf::Message {
 public:
  M3ActuatorStatus();
  virtual ~M3ActuatorStatus();

  M3ActuatorStatus(const M3ActuatorStatus& from);

  inline M3ActuatorStatus& operator=(const M3ActuatorStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorStatus& default_instance();

  void Swap(M3ActuatorStatus* other);

  // implements Message ----------------------------------------------

  M3ActuatorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorStatus& from);
  void MergeFrom(const M3ActuatorStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .M3BaseStatus base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::M3BaseStatus& base() const;
  inline ::M3BaseStatus* mutable_base();
  inline ::M3BaseStatus* release_base();
  inline void set_allocated_base(::M3BaseStatus* base);

  // optional double motor_temp = 2;
  inline bool has_motor_temp() const;
  inline void clear_motor_temp();
  static const int kMotorTempFieldNumber = 2;
  inline double motor_temp() const;
  inline void set_motor_temp(double value);

  // optional double amp_temp = 3;
  inline bool has_amp_temp() const;
  inline void clear_amp_temp();
  static const int kAmpTempFieldNumber = 3;
  inline double amp_temp() const;
  inline void set_amp_temp(double value);

  // optional double current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline double current() const;
  inline void set_current(double value);

  // optional double torque = 5;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 5;
  inline double torque() const;
  inline void set_torque(double value);

  // optional double torquedot = 6;
  inline bool has_torquedot() const;
  inline void clear_torquedot();
  static const int kTorquedotFieldNumber = 6;
  inline double torquedot() const;
  inline void set_torquedot(double value);

  // optional double theta = 7;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 7;
  inline double theta() const;
  inline void set_theta(double value);

  // optional double thetadot = 8;
  inline bool has_thetadot() const;
  inline void clear_thetadot();
  static const int kThetadotFieldNumber = 8;
  inline double thetadot() const;
  inline void set_thetadot(double value);

  // optional double thetadotdot = 9;
  inline bool has_thetadotdot() const;
  inline void clear_thetadotdot();
  static const int kThetadotdotFieldNumber = 9;
  inline double thetadotdot() const;
  inline void set_thetadotdot(double value);

  // optional double torque_error = 10;
  inline bool has_torque_error() const;
  inline void clear_torque_error();
  static const int kTorqueErrorFieldNumber = 10;
  inline double torque_error() const;
  inline void set_torque_error(double value);

  // optional int32 pwm_cmd = 11;
  inline bool has_pwm_cmd() const;
  inline void clear_pwm_cmd();
  static const int kPwmCmdFieldNumber = 11;
  inline ::google::protobuf::int32 pwm_cmd() const;
  inline void set_pwm_cmd(::google::protobuf::int32 value);

  // optional double ambient_temp = 12;
  inline bool has_ambient_temp() const;
  inline void clear_ambient_temp();
  static const int kAmbientTempFieldNumber = 12;
  inline double ambient_temp() const;
  inline void set_ambient_temp(double value);

  // optional double case_temp = 13;
  inline bool has_case_temp() const;
  inline void clear_case_temp();
  static const int kCaseTempFieldNumber = 13;
  inline double case_temp() const;
  inline void set_case_temp(double value);

  // optional double power = 14;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 14;
  inline double power() const;
  inline void set_power(double value);

  // optional int32 flags = 15;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 15;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);

  // optional double ext_temp = 16;
  inline bool has_ext_temp() const;
  inline void clear_ext_temp();
  static const int kExtTempFieldNumber = 16;
  inline double ext_temp() const;
  inline void set_ext_temp(double value);

  // optional double tq_cmd = 17;
  inline bool has_tq_cmd() const;
  inline void clear_tq_cmd();
  static const int kTqCmdFieldNumber = 17;
  inline double tq_cmd() const;
  inline void set_tq_cmd(double value);

  // optional double i_cmd = 18;
  inline bool has_i_cmd() const;
  inline void clear_i_cmd();
  static const int kICmdFieldNumber = 18;
  inline double i_cmd() const;
  inline void set_i_cmd(double value);

  // optional double mode_cmd = 19;
  inline bool has_mode_cmd() const;
  inline void clear_mode_cmd();
  static const int kModeCmdFieldNumber = 19;
  inline double mode_cmd() const;
  inline void set_mode_cmd(double value);

  // @@protoc_insertion_point(class_scope:M3ActuatorStatus)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_motor_temp();
  inline void clear_has_motor_temp();
  inline void set_has_amp_temp();
  inline void clear_has_amp_temp();
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_torquedot();
  inline void clear_has_torquedot();
  inline void set_has_theta();
  inline void clear_has_theta();
  inline void set_has_thetadot();
  inline void clear_has_thetadot();
  inline void set_has_thetadotdot();
  inline void clear_has_thetadotdot();
  inline void set_has_torque_error();
  inline void clear_has_torque_error();
  inline void set_has_pwm_cmd();
  inline void clear_has_pwm_cmd();
  inline void set_has_ambient_temp();
  inline void clear_has_ambient_temp();
  inline void set_has_case_temp();
  inline void clear_has_case_temp();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_ext_temp();
  inline void clear_has_ext_temp();
  inline void set_has_tq_cmd();
  inline void clear_has_tq_cmd();
  inline void set_has_i_cmd();
  inline void clear_has_i_cmd();
  inline void set_has_mode_cmd();
  inline void clear_has_mode_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::M3BaseStatus* base_;
  double motor_temp_;
  double amp_temp_;
  double current_;
  double torque_;
  double torquedot_;
  double theta_;
  double thetadot_;
  double thetadotdot_;
  double torque_error_;
  double ambient_temp_;
  double case_temp_;
  ::google::protobuf::int32 pwm_cmd_;
  ::google::protobuf::int32 flags_;
  double power_;
  double ext_temp_;
  double tq_cmd_;
  double i_cmd_;
  double mode_cmd_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();

  void InitAsDefaultInstance();
  static M3ActuatorStatus* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorParamFilter : public ::google::protobuf::Message {
 public:
  M3ActuatorParamFilter();
  virtual ~M3ActuatorParamFilter();

  M3ActuatorParamFilter(const M3ActuatorParamFilter& from);

  inline M3ActuatorParamFilter& operator=(const M3ActuatorParamFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorParamFilter& default_instance();

  void Swap(M3ActuatorParamFilter* other);

  // implements Message ----------------------------------------------

  M3ActuatorParamFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorParamFilter& from);
  void MergeFrom(const M3ActuatorParamFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // optional double cutoff_freq = 2;
  inline bool has_cutoff_freq() const;
  inline void clear_cutoff_freq();
  static const int kCutoffFreqFieldNumber = 2;
  inline double cutoff_freq() const;
  inline void set_cutoff_freq(double value);

  // optional int32 n = 3;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 3;
  inline ::google::protobuf::int32 n() const;
  inline void set_n(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:M3ActuatorParamFilter)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_cutoff_freq();
  inline void clear_has_cutoff_freq();
  inline void set_has_n();
  inline void clear_has_n();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double cutoff_freq_;
  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 n_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();

  void InitAsDefaultInstance();
  static M3ActuatorParamFilter* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorParamPID : public ::google::protobuf::Message {
 public:
  M3ActuatorParamPID();
  virtual ~M3ActuatorParamPID();

  M3ActuatorParamPID(const M3ActuatorParamPID& from);

  inline M3ActuatorParamPID& operator=(const M3ActuatorParamPID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorParamPID& default_instance();

  void Swap(M3ActuatorParamPID* other);

  // implements Message ----------------------------------------------

  M3ActuatorParamPID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorParamPID& from);
  void MergeFrom(const M3ActuatorParamPID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double k_p = 1;
  inline bool has_k_p() const;
  inline void clear_k_p();
  static const int kKPFieldNumber = 1;
  inline double k_p() const;
  inline void set_k_p(double value);

  // optional double k_i = 2;
  inline bool has_k_i() const;
  inline void clear_k_i();
  static const int kKIFieldNumber = 2;
  inline double k_i() const;
  inline void set_k_i(double value);

  // optional double k_d = 3;
  inline bool has_k_d() const;
  inline void clear_k_d();
  static const int kKDFieldNumber = 3;
  inline double k_d() const;
  inline void set_k_d(double value);

  // optional double k_i_limit = 4;
  inline bool has_k_i_limit() const;
  inline void clear_k_i_limit();
  static const int kKILimitFieldNumber = 4;
  inline double k_i_limit() const;
  inline void set_k_i_limit(double value);

  // optional double k_i_range = 5;
  inline bool has_k_i_range() const;
  inline void clear_k_i_range();
  static const int kKIRangeFieldNumber = 5;
  inline double k_i_range() const;
  inline void set_k_i_range(double value);

  // @@protoc_insertion_point(class_scope:M3ActuatorParamPID)
 private:
  inline void set_has_k_p();
  inline void clear_has_k_p();
  inline void set_has_k_i();
  inline void clear_has_k_i();
  inline void set_has_k_d();
  inline void clear_has_k_d();
  inline void set_has_k_i_limit();
  inline void clear_has_k_i_limit();
  inline void set_has_k_i_range();
  inline void clear_has_k_i_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double k_p_;
  double k_i_;
  double k_d_;
  double k_i_limit_;
  double k_i_range_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();

  void InitAsDefaultInstance();
  static M3ActuatorParamPID* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorParamAngleDf : public ::google::protobuf::Message {
 public:
  M3ActuatorParamAngleDf();
  virtual ~M3ActuatorParamAngleDf();

  M3ActuatorParamAngleDf(const M3ActuatorParamAngleDf& from);

  inline M3ActuatorParamAngleDf& operator=(const M3ActuatorParamAngleDf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorParamAngleDf& default_instance();

  void Swap(M3ActuatorParamAngleDf* other);

  // implements Message ----------------------------------------------

  M3ActuatorParamAngleDf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorParamAngleDf& from);
  void MergeFrom(const M3ActuatorParamAngleDf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .M3ActuatorParamFilter theta_df = 1;
  inline bool has_theta_df() const;
  inline void clear_theta_df();
  static const int kThetaDfFieldNumber = 1;
  inline const ::M3ActuatorParamFilter& theta_df() const;
  inline ::M3ActuatorParamFilter* mutable_theta_df();
  inline ::M3ActuatorParamFilter* release_theta_df();
  inline void set_allocated_theta_df(::M3ActuatorParamFilter* theta_df);

  // optional .M3ActuatorParamFilter thetadot_df = 2;
  inline bool has_thetadot_df() const;
  inline void clear_thetadot_df();
  static const int kThetadotDfFieldNumber = 2;
  inline const ::M3ActuatorParamFilter& thetadot_df() const;
  inline ::M3ActuatorParamFilter* mutable_thetadot_df();
  inline ::M3ActuatorParamFilter* release_thetadot_df();
  inline void set_allocated_thetadot_df(::M3ActuatorParamFilter* thetadot_df);

  // optional .M3ActuatorParamFilter thetadotdot_df = 3;
  inline bool has_thetadotdot_df() const;
  inline void clear_thetadotdot_df();
  static const int kThetadotdotDfFieldNumber = 3;
  inline const ::M3ActuatorParamFilter& thetadotdot_df() const;
  inline ::M3ActuatorParamFilter* mutable_thetadotdot_df();
  inline ::M3ActuatorParamFilter* release_thetadotdot_df();
  inline void set_allocated_thetadotdot_df(::M3ActuatorParamFilter* thetadotdot_df);

  // @@protoc_insertion_point(class_scope:M3ActuatorParamAngleDf)
 private:
  inline void set_has_theta_df();
  inline void clear_has_theta_df();
  inline void set_has_thetadot_df();
  inline void clear_has_thetadot_df();
  inline void set_has_thetadotdot_df();
  inline void clear_has_thetadotdot_df();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::M3ActuatorParamFilter* theta_df_;
  ::M3ActuatorParamFilter* thetadot_df_;
  ::M3ActuatorParamFilter* thetadotdot_df_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();

  void InitAsDefaultInstance();
  static M3ActuatorParamAngleDf* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorParam : public ::google::protobuf::Message {
 public:
  M3ActuatorParam();
  virtual ~M3ActuatorParam();

  M3ActuatorParam(const M3ActuatorParam& from);

  inline M3ActuatorParam& operator=(const M3ActuatorParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorParam& default_instance();

  void Swap(M3ActuatorParam* other);

  // implements Message ----------------------------------------------

  M3ActuatorParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorParam& from);
  void MergeFrom(const M3ActuatorParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double k_qdot_virtual = 10;
  inline bool has_k_qdot_virtual() const;
  inline void clear_k_qdot_virtual();
  static const int kKQdotVirtualFieldNumber = 10;
  inline double k_qdot_virtual() const;
  inline void set_k_qdot_virtual(double value);

  // optional double k_qdotdot_virtual = 11;
  inline bool has_k_qdotdot_virtual() const;
  inline void clear_k_qdotdot_virtual();
  static const int kKQdotdotVirtualFieldNumber = 11;
  inline double k_qdotdot_virtual() const;
  inline void set_k_qdotdot_virtual(double value);

  // optional double max_tq = 1;
  inline bool has_max_tq() const;
  inline void clear_max_tq();
  static const int kMaxTqFieldNumber = 1;
  inline double max_tq() const;
  inline void set_max_tq(double value);

  // optional double min_tq = 2;
  inline bool has_min_tq() const;
  inline void clear_min_tq();
  static const int kMinTqFieldNumber = 2;
  inline double min_tq() const;
  inline void set_min_tq(double value);

  // optional double max_i = 3;
  inline bool has_max_i() const;
  inline void clear_max_i();
  static const int kMaxIFieldNumber = 3;
  inline double max_i() const;
  inline void set_max_i(double value);

  // optional double max_amp_current = 4;
  inline bool has_max_amp_current() const;
  inline void clear_max_amp_current();
  static const int kMaxAmpCurrentFieldNumber = 4;
  inline double max_amp_current() const;
  inline void set_max_amp_current(double value);

  // optional double max_overload_time = 5;
  inline bool has_max_overload_time() const;
  inline void clear_max_overload_time();
  static const int kMaxOverloadTimeFieldNumber = 5;
  inline double max_overload_time() const;
  inline void set_max_overload_time(double value);

  // optional double max_amp_temp = 6;
  inline bool has_max_amp_temp() const;
  inline void clear_max_amp_temp();
  static const int kMaxAmpTempFieldNumber = 6;
  inline double max_amp_temp() const;
  inline void set_max_amp_temp(double value);

  // optional .M3ActuatorParamPID pid_torque = 7;
  inline bool has_pid_torque() const;
  inline void clear_pid_torque();
  static const int kPidTorqueFieldNumber = 7;
  inline const ::M3ActuatorParamPID& pid_torque() const;
  inline ::M3ActuatorParamPID* mutable_pid_torque();
  inline ::M3ActuatorParamPID* release_pid_torque();
  inline void set_allocated_pid_torque(::M3ActuatorParamPID* pid_torque);

  // optional .M3ActuatorParamAngleDf angle_df = 8;
  inline bool has_angle_df() const;
  inline void clear_angle_df();
  static const int kAngleDfFieldNumber = 8;
  inline const ::M3ActuatorParamAngleDf& angle_df() const;
  inline ::M3ActuatorParamAngleDf* mutable_angle_df();
  inline ::M3ActuatorParamAngleDf* release_angle_df();
  inline void set_allocated_angle_df(::M3ActuatorParamAngleDf* angle_df);

  // optional .M3ActuatorParamFilter torquedot_df = 9;
  inline bool has_torquedot_df() const;
  inline void clear_torquedot_df();
  static const int kTorquedotDfFieldNumber = 9;
  inline const ::M3ActuatorParamFilter& torquedot_df() const;
  inline ::M3ActuatorParamFilter* mutable_torquedot_df();
  inline ::M3ActuatorParamFilter* release_torquedot_df();
  inline void set_allocated_torquedot_df(::M3ActuatorParamFilter* torquedot_df);

  // @@protoc_insertion_point(class_scope:M3ActuatorParam)
 private:
  inline void set_has_k_qdot_virtual();
  inline void clear_has_k_qdot_virtual();
  inline void set_has_k_qdotdot_virtual();
  inline void clear_has_k_qdotdot_virtual();
  inline void set_has_max_tq();
  inline void clear_has_max_tq();
  inline void set_has_min_tq();
  inline void clear_has_min_tq();
  inline void set_has_max_i();
  inline void clear_has_max_i();
  inline void set_has_max_amp_current();
  inline void clear_has_max_amp_current();
  inline void set_has_max_overload_time();
  inline void clear_has_max_overload_time();
  inline void set_has_max_amp_temp();
  inline void clear_has_max_amp_temp();
  inline void set_has_pid_torque();
  inline void clear_has_pid_torque();
  inline void set_has_angle_df();
  inline void clear_has_angle_df();
  inline void set_has_torquedot_df();
  inline void clear_has_torquedot_df();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double k_qdot_virtual_;
  double k_qdotdot_virtual_;
  double max_tq_;
  double min_tq_;
  double max_i_;
  double max_amp_current_;
  double max_overload_time_;
  double max_amp_temp_;
  ::M3ActuatorParamPID* pid_torque_;
  ::M3ActuatorParamAngleDf* angle_df_;
  ::M3ActuatorParamFilter* torquedot_df_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();

  void InitAsDefaultInstance();
  static M3ActuatorParam* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorCommand : public ::google::protobuf::Message {
 public:
  M3ActuatorCommand();
  virtual ~M3ActuatorCommand();

  M3ActuatorCommand(const M3ActuatorCommand& from);

  inline M3ActuatorCommand& operator=(const M3ActuatorCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorCommand& default_instance();

  void Swap(M3ActuatorCommand* other);

  // implements Message ----------------------------------------------

  M3ActuatorCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorCommand& from);
  void MergeFrom(const M3ActuatorCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pwm_desired = 1;
  inline bool has_pwm_desired() const;
  inline void clear_pwm_desired();
  static const int kPwmDesiredFieldNumber = 1;
  inline ::google::protobuf::int32 pwm_desired() const;
  inline void set_pwm_desired(::google::protobuf::int32 value);

  // optional double tq_desired = 2;
  inline bool has_tq_desired() const;
  inline void clear_tq_desired();
  static const int kTqDesiredFieldNumber = 2;
  inline double tq_desired() const;
  inline void set_tq_desired(double value);

  // optional double i_desired = 3;
  inline bool has_i_desired() const;
  inline void clear_i_desired();
  static const int kIDesiredFieldNumber = 3;
  inline double i_desired() const;
  inline void set_i_desired(double value);

  // optional .ACTUATOR_MODE ctrl_mode = 4;
  inline bool has_ctrl_mode() const;
  inline void clear_ctrl_mode();
  static const int kCtrlModeFieldNumber = 4;
  inline ::ACTUATOR_MODE ctrl_mode() const;
  inline void set_ctrl_mode(::ACTUATOR_MODE value);

  // optional bool brake_off = 5;
  inline bool has_brake_off() const;
  inline void clear_brake_off();
  static const int kBrakeOffFieldNumber = 5;
  inline bool brake_off() const;
  inline void set_brake_off(bool value);

  // @@protoc_insertion_point(class_scope:M3ActuatorCommand)
 private:
  inline void set_has_pwm_desired();
  inline void clear_has_pwm_desired();
  inline void set_has_tq_desired();
  inline void clear_has_tq_desired();
  inline void set_has_i_desired();
  inline void clear_has_i_desired();
  inline void set_has_ctrl_mode();
  inline void clear_has_ctrl_mode();
  inline void set_has_brake_off();
  inline void clear_has_brake_off();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double tq_desired_;
  ::google::protobuf::int32 pwm_desired_;
  int ctrl_mode_;
  double i_desired_;
  bool brake_off_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();

  void InitAsDefaultInstance();
  static M3ActuatorCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// M3ActuatorStatus

// optional .M3BaseStatus base = 1;
inline bool M3ActuatorStatus::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorStatus::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorStatus::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorStatus::clear_base() {
  if (base_ != NULL) base_->::M3BaseStatus::Clear();
  clear_has_base();
}
inline const ::M3BaseStatus& M3ActuatorStatus::base() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::M3BaseStatus* M3ActuatorStatus::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::M3BaseStatus;
  // @@protoc_insertion_point(field_mutable:M3ActuatorStatus.base)
  return base_;
}
inline ::M3BaseStatus* M3ActuatorStatus::release_base() {
  clear_has_base();
  ::M3BaseStatus* temp = base_;
  base_ = NULL;
  return temp;
}
inline void M3ActuatorStatus::set_allocated_base(::M3BaseStatus* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:M3ActuatorStatus.base)
}

// optional double motor_temp = 2;
inline bool M3ActuatorStatus::has_motor_temp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorStatus::set_has_motor_temp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorStatus::clear_has_motor_temp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorStatus::clear_motor_temp() {
  motor_temp_ = 0;
  clear_has_motor_temp();
}
inline double M3ActuatorStatus::motor_temp() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.motor_temp)
  return motor_temp_;
}
inline void M3ActuatorStatus::set_motor_temp(double value) {
  set_has_motor_temp();
  motor_temp_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.motor_temp)
}

// optional double amp_temp = 3;
inline bool M3ActuatorStatus::has_amp_temp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorStatus::set_has_amp_temp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorStatus::clear_has_amp_temp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorStatus::clear_amp_temp() {
  amp_temp_ = 0;
  clear_has_amp_temp();
}
inline double M3ActuatorStatus::amp_temp() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.amp_temp)
  return amp_temp_;
}
inline void M3ActuatorStatus::set_amp_temp(double value) {
  set_has_amp_temp();
  amp_temp_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.amp_temp)
}

// optional double current = 4;
inline bool M3ActuatorStatus::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorStatus::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorStatus::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorStatus::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline double M3ActuatorStatus::current() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.current)
  return current_;
}
inline void M3ActuatorStatus::set_current(double value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.current)
}

// optional double torque = 5;
inline bool M3ActuatorStatus::has_torque() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorStatus::set_has_torque() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorStatus::clear_has_torque() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorStatus::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline double M3ActuatorStatus::torque() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.torque)
  return torque_;
}
inline void M3ActuatorStatus::set_torque(double value) {
  set_has_torque();
  torque_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.torque)
}

// optional double torquedot = 6;
inline bool M3ActuatorStatus::has_torquedot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3ActuatorStatus::set_has_torquedot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3ActuatorStatus::clear_has_torquedot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3ActuatorStatus::clear_torquedot() {
  torquedot_ = 0;
  clear_has_torquedot();
}
inline double M3ActuatorStatus::torquedot() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.torquedot)
  return torquedot_;
}
inline void M3ActuatorStatus::set_torquedot(double value) {
  set_has_torquedot();
  torquedot_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.torquedot)
}

// optional double theta = 7;
inline bool M3ActuatorStatus::has_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void M3ActuatorStatus::set_has_theta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void M3ActuatorStatus::clear_has_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void M3ActuatorStatus::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double M3ActuatorStatus::theta() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.theta)
  return theta_;
}
inline void M3ActuatorStatus::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.theta)
}

// optional double thetadot = 8;
inline bool M3ActuatorStatus::has_thetadot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void M3ActuatorStatus::set_has_thetadot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void M3ActuatorStatus::clear_has_thetadot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void M3ActuatorStatus::clear_thetadot() {
  thetadot_ = 0;
  clear_has_thetadot();
}
inline double M3ActuatorStatus::thetadot() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.thetadot)
  return thetadot_;
}
inline void M3ActuatorStatus::set_thetadot(double value) {
  set_has_thetadot();
  thetadot_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.thetadot)
}

// optional double thetadotdot = 9;
inline bool M3ActuatorStatus::has_thetadotdot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void M3ActuatorStatus::set_has_thetadotdot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void M3ActuatorStatus::clear_has_thetadotdot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void M3ActuatorStatus::clear_thetadotdot() {
  thetadotdot_ = 0;
  clear_has_thetadotdot();
}
inline double M3ActuatorStatus::thetadotdot() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.thetadotdot)
  return thetadotdot_;
}
inline void M3ActuatorStatus::set_thetadotdot(double value) {
  set_has_thetadotdot();
  thetadotdot_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.thetadotdot)
}

// optional double torque_error = 10;
inline bool M3ActuatorStatus::has_torque_error() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void M3ActuatorStatus::set_has_torque_error() {
  _has_bits_[0] |= 0x00000200u;
}
inline void M3ActuatorStatus::clear_has_torque_error() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void M3ActuatorStatus::clear_torque_error() {
  torque_error_ = 0;
  clear_has_torque_error();
}
inline double M3ActuatorStatus::torque_error() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.torque_error)
  return torque_error_;
}
inline void M3ActuatorStatus::set_torque_error(double value) {
  set_has_torque_error();
  torque_error_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.torque_error)
}

// optional int32 pwm_cmd = 11;
inline bool M3ActuatorStatus::has_pwm_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void M3ActuatorStatus::set_has_pwm_cmd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void M3ActuatorStatus::clear_has_pwm_cmd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void M3ActuatorStatus::clear_pwm_cmd() {
  pwm_cmd_ = 0;
  clear_has_pwm_cmd();
}
inline ::google::protobuf::int32 M3ActuatorStatus::pwm_cmd() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.pwm_cmd)
  return pwm_cmd_;
}
inline void M3ActuatorStatus::set_pwm_cmd(::google::protobuf::int32 value) {
  set_has_pwm_cmd();
  pwm_cmd_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.pwm_cmd)
}

// optional double ambient_temp = 12;
inline bool M3ActuatorStatus::has_ambient_temp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void M3ActuatorStatus::set_has_ambient_temp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void M3ActuatorStatus::clear_has_ambient_temp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void M3ActuatorStatus::clear_ambient_temp() {
  ambient_temp_ = 0;
  clear_has_ambient_temp();
}
inline double M3ActuatorStatus::ambient_temp() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.ambient_temp)
  return ambient_temp_;
}
inline void M3ActuatorStatus::set_ambient_temp(double value) {
  set_has_ambient_temp();
  ambient_temp_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.ambient_temp)
}

// optional double case_temp = 13;
inline bool M3ActuatorStatus::has_case_temp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void M3ActuatorStatus::set_has_case_temp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void M3ActuatorStatus::clear_has_case_temp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void M3ActuatorStatus::clear_case_temp() {
  case_temp_ = 0;
  clear_has_case_temp();
}
inline double M3ActuatorStatus::case_temp() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.case_temp)
  return case_temp_;
}
inline void M3ActuatorStatus::set_case_temp(double value) {
  set_has_case_temp();
  case_temp_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.case_temp)
}

// optional double power = 14;
inline bool M3ActuatorStatus::has_power() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void M3ActuatorStatus::set_has_power() {
  _has_bits_[0] |= 0x00002000u;
}
inline void M3ActuatorStatus::clear_has_power() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void M3ActuatorStatus::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline double M3ActuatorStatus::power() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.power)
  return power_;
}
inline void M3ActuatorStatus::set_power(double value) {
  set_has_power();
  power_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.power)
}

// optional int32 flags = 15;
inline bool M3ActuatorStatus::has_flags() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void M3ActuatorStatus::set_has_flags() {
  _has_bits_[0] |= 0x00004000u;
}
inline void M3ActuatorStatus::clear_has_flags() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void M3ActuatorStatus::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 M3ActuatorStatus::flags() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.flags)
  return flags_;
}
inline void M3ActuatorStatus::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.flags)
}

// optional double ext_temp = 16;
inline bool M3ActuatorStatus::has_ext_temp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void M3ActuatorStatus::set_has_ext_temp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void M3ActuatorStatus::clear_has_ext_temp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void M3ActuatorStatus::clear_ext_temp() {
  ext_temp_ = 0;
  clear_has_ext_temp();
}
inline double M3ActuatorStatus::ext_temp() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.ext_temp)
  return ext_temp_;
}
inline void M3ActuatorStatus::set_ext_temp(double value) {
  set_has_ext_temp();
  ext_temp_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.ext_temp)
}

// optional double tq_cmd = 17;
inline bool M3ActuatorStatus::has_tq_cmd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void M3ActuatorStatus::set_has_tq_cmd() {
  _has_bits_[0] |= 0x00010000u;
}
inline void M3ActuatorStatus::clear_has_tq_cmd() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void M3ActuatorStatus::clear_tq_cmd() {
  tq_cmd_ = 0;
  clear_has_tq_cmd();
}
inline double M3ActuatorStatus::tq_cmd() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.tq_cmd)
  return tq_cmd_;
}
inline void M3ActuatorStatus::set_tq_cmd(double value) {
  set_has_tq_cmd();
  tq_cmd_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.tq_cmd)
}

// optional double i_cmd = 18;
inline bool M3ActuatorStatus::has_i_cmd() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void M3ActuatorStatus::set_has_i_cmd() {
  _has_bits_[0] |= 0x00020000u;
}
inline void M3ActuatorStatus::clear_has_i_cmd() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void M3ActuatorStatus::clear_i_cmd() {
  i_cmd_ = 0;
  clear_has_i_cmd();
}
inline double M3ActuatorStatus::i_cmd() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.i_cmd)
  return i_cmd_;
}
inline void M3ActuatorStatus::set_i_cmd(double value) {
  set_has_i_cmd();
  i_cmd_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.i_cmd)
}

// optional double mode_cmd = 19;
inline bool M3ActuatorStatus::has_mode_cmd() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void M3ActuatorStatus::set_has_mode_cmd() {
  _has_bits_[0] |= 0x00040000u;
}
inline void M3ActuatorStatus::clear_has_mode_cmd() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void M3ActuatorStatus::clear_mode_cmd() {
  mode_cmd_ = 0;
  clear_has_mode_cmd();
}
inline double M3ActuatorStatus::mode_cmd() const {
  // @@protoc_insertion_point(field_get:M3ActuatorStatus.mode_cmd)
  return mode_cmd_;
}
inline void M3ActuatorStatus::set_mode_cmd(double value) {
  set_has_mode_cmd();
  mode_cmd_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorStatus.mode_cmd)
}

// -------------------------------------------------------------------

// M3ActuatorParamFilter

// optional int32 order = 1;
inline bool M3ActuatorParamFilter::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorParamFilter::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorParamFilter::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorParamFilter::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 M3ActuatorParamFilter::order() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamFilter.order)
  return order_;
}
inline void M3ActuatorParamFilter::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamFilter.order)
}

// optional double cutoff_freq = 2;
inline bool M3ActuatorParamFilter::has_cutoff_freq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorParamFilter::set_has_cutoff_freq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorParamFilter::clear_has_cutoff_freq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorParamFilter::clear_cutoff_freq() {
  cutoff_freq_ = 0;
  clear_has_cutoff_freq();
}
inline double M3ActuatorParamFilter::cutoff_freq() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamFilter.cutoff_freq)
  return cutoff_freq_;
}
inline void M3ActuatorParamFilter::set_cutoff_freq(double value) {
  set_has_cutoff_freq();
  cutoff_freq_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamFilter.cutoff_freq)
}

// optional int32 n = 3;
inline bool M3ActuatorParamFilter::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorParamFilter::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorParamFilter::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorParamFilter::clear_n() {
  n_ = 0;
  clear_has_n();
}
inline ::google::protobuf::int32 M3ActuatorParamFilter::n() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamFilter.n)
  return n_;
}
inline void M3ActuatorParamFilter::set_n(::google::protobuf::int32 value) {
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamFilter.n)
}

// -------------------------------------------------------------------

// M3ActuatorParamPID

// optional double k_p = 1;
inline bool M3ActuatorParamPID::has_k_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorParamPID::clear_has_k_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorParamPID::clear_k_p() {
  k_p_ = 0;
  clear_has_k_p();
}
inline double M3ActuatorParamPID::k_p() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamPID.k_p)
  return k_p_;
}
inline void M3ActuatorParamPID::set_k_p(double value) {
  set_has_k_p();
  k_p_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamPID.k_p)
}

// optional double k_i = 2;
inline bool M3ActuatorParamPID::has_k_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorParamPID::clear_has_k_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorParamPID::clear_k_i() {
  k_i_ = 0;
  clear_has_k_i();
}
inline double M3ActuatorParamPID::k_i() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamPID.k_i)
  return k_i_;
}
inline void M3ActuatorParamPID::set_k_i(double value) {
  set_has_k_i();
  k_i_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamPID.k_i)
}

// optional double k_d = 3;
inline bool M3ActuatorParamPID::has_k_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorParamPID::clear_has_k_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorParamPID::clear_k_d() {
  k_d_ = 0;
  clear_has_k_d();
}
inline double M3ActuatorParamPID::k_d() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamPID.k_d)
  return k_d_;
}
inline void M3ActuatorParamPID::set_k_d(double value) {
  set_has_k_d();
  k_d_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamPID.k_d)
}

// optional double k_i_limit = 4;
inline bool M3ActuatorParamPID::has_k_i_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_i_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorParamPID::clear_has_k_i_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorParamPID::clear_k_i_limit() {
  k_i_limit_ = 0;
  clear_has_k_i_limit();
}
inline double M3ActuatorParamPID::k_i_limit() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamPID.k_i_limit)
  return k_i_limit_;
}
inline void M3ActuatorParamPID::set_k_i_limit(double value) {
  set_has_k_i_limit();
  k_i_limit_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamPID.k_i_limit)
}

// optional double k_i_range = 5;
inline bool M3ActuatorParamPID::has_k_i_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_i_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorParamPID::clear_has_k_i_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorParamPID::clear_k_i_range() {
  k_i_range_ = 0;
  clear_has_k_i_range();
}
inline double M3ActuatorParamPID::k_i_range() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamPID.k_i_range)
  return k_i_range_;
}
inline void M3ActuatorParamPID::set_k_i_range(double value) {
  set_has_k_i_range();
  k_i_range_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParamPID.k_i_range)
}

// -------------------------------------------------------------------

// M3ActuatorParamAngleDf

// optional .M3ActuatorParamFilter theta_df = 1;
inline bool M3ActuatorParamAngleDf::has_theta_df() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorParamAngleDf::set_has_theta_df() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorParamAngleDf::clear_has_theta_df() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorParamAngleDf::clear_theta_df() {
  if (theta_df_ != NULL) theta_df_->::M3ActuatorParamFilter::Clear();
  clear_has_theta_df();
}
inline const ::M3ActuatorParamFilter& M3ActuatorParamAngleDf::theta_df() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamAngleDf.theta_df)
  return theta_df_ != NULL ? *theta_df_ : *default_instance_->theta_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParamAngleDf::mutable_theta_df() {
  set_has_theta_df();
  if (theta_df_ == NULL) theta_df_ = new ::M3ActuatorParamFilter;
  // @@protoc_insertion_point(field_mutable:M3ActuatorParamAngleDf.theta_df)
  return theta_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParamAngleDf::release_theta_df() {
  clear_has_theta_df();
  ::M3ActuatorParamFilter* temp = theta_df_;
  theta_df_ = NULL;
  return temp;
}
inline void M3ActuatorParamAngleDf::set_allocated_theta_df(::M3ActuatorParamFilter* theta_df) {
  delete theta_df_;
  theta_df_ = theta_df;
  if (theta_df) {
    set_has_theta_df();
  } else {
    clear_has_theta_df();
  }
  // @@protoc_insertion_point(field_set_allocated:M3ActuatorParamAngleDf.theta_df)
}

// optional .M3ActuatorParamFilter thetadot_df = 2;
inline bool M3ActuatorParamAngleDf::has_thetadot_df() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorParamAngleDf::set_has_thetadot_df() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorParamAngleDf::clear_has_thetadot_df() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorParamAngleDf::clear_thetadot_df() {
  if (thetadot_df_ != NULL) thetadot_df_->::M3ActuatorParamFilter::Clear();
  clear_has_thetadot_df();
}
inline const ::M3ActuatorParamFilter& M3ActuatorParamAngleDf::thetadot_df() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamAngleDf.thetadot_df)
  return thetadot_df_ != NULL ? *thetadot_df_ : *default_instance_->thetadot_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParamAngleDf::mutable_thetadot_df() {
  set_has_thetadot_df();
  if (thetadot_df_ == NULL) thetadot_df_ = new ::M3ActuatorParamFilter;
  // @@protoc_insertion_point(field_mutable:M3ActuatorParamAngleDf.thetadot_df)
  return thetadot_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParamAngleDf::release_thetadot_df() {
  clear_has_thetadot_df();
  ::M3ActuatorParamFilter* temp = thetadot_df_;
  thetadot_df_ = NULL;
  return temp;
}
inline void M3ActuatorParamAngleDf::set_allocated_thetadot_df(::M3ActuatorParamFilter* thetadot_df) {
  delete thetadot_df_;
  thetadot_df_ = thetadot_df;
  if (thetadot_df) {
    set_has_thetadot_df();
  } else {
    clear_has_thetadot_df();
  }
  // @@protoc_insertion_point(field_set_allocated:M3ActuatorParamAngleDf.thetadot_df)
}

// optional .M3ActuatorParamFilter thetadotdot_df = 3;
inline bool M3ActuatorParamAngleDf::has_thetadotdot_df() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorParamAngleDf::set_has_thetadotdot_df() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorParamAngleDf::clear_has_thetadotdot_df() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorParamAngleDf::clear_thetadotdot_df() {
  if (thetadotdot_df_ != NULL) thetadotdot_df_->::M3ActuatorParamFilter::Clear();
  clear_has_thetadotdot_df();
}
inline const ::M3ActuatorParamFilter& M3ActuatorParamAngleDf::thetadotdot_df() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParamAngleDf.thetadotdot_df)
  return thetadotdot_df_ != NULL ? *thetadotdot_df_ : *default_instance_->thetadotdot_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParamAngleDf::mutable_thetadotdot_df() {
  set_has_thetadotdot_df();
  if (thetadotdot_df_ == NULL) thetadotdot_df_ = new ::M3ActuatorParamFilter;
  // @@protoc_insertion_point(field_mutable:M3ActuatorParamAngleDf.thetadotdot_df)
  return thetadotdot_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParamAngleDf::release_thetadotdot_df() {
  clear_has_thetadotdot_df();
  ::M3ActuatorParamFilter* temp = thetadotdot_df_;
  thetadotdot_df_ = NULL;
  return temp;
}
inline void M3ActuatorParamAngleDf::set_allocated_thetadotdot_df(::M3ActuatorParamFilter* thetadotdot_df) {
  delete thetadotdot_df_;
  thetadotdot_df_ = thetadotdot_df;
  if (thetadotdot_df) {
    set_has_thetadotdot_df();
  } else {
    clear_has_thetadotdot_df();
  }
  // @@protoc_insertion_point(field_set_allocated:M3ActuatorParamAngleDf.thetadotdot_df)
}

// -------------------------------------------------------------------

// M3ActuatorParam

// optional double k_qdot_virtual = 10;
inline bool M3ActuatorParam::has_k_qdot_virtual() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorParam::set_has_k_qdot_virtual() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorParam::clear_has_k_qdot_virtual() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorParam::clear_k_qdot_virtual() {
  k_qdot_virtual_ = 0;
  clear_has_k_qdot_virtual();
}
inline double M3ActuatorParam::k_qdot_virtual() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.k_qdot_virtual)
  return k_qdot_virtual_;
}
inline void M3ActuatorParam::set_k_qdot_virtual(double value) {
  set_has_k_qdot_virtual();
  k_qdot_virtual_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.k_qdot_virtual)
}

// optional double k_qdotdot_virtual = 11;
inline bool M3ActuatorParam::has_k_qdotdot_virtual() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorParam::set_has_k_qdotdot_virtual() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorParam::clear_has_k_qdotdot_virtual() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorParam::clear_k_qdotdot_virtual() {
  k_qdotdot_virtual_ = 0;
  clear_has_k_qdotdot_virtual();
}
inline double M3ActuatorParam::k_qdotdot_virtual() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.k_qdotdot_virtual)
  return k_qdotdot_virtual_;
}
inline void M3ActuatorParam::set_k_qdotdot_virtual(double value) {
  set_has_k_qdotdot_virtual();
  k_qdotdot_virtual_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.k_qdotdot_virtual)
}

// optional double max_tq = 1;
inline bool M3ActuatorParam::has_max_tq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorParam::set_has_max_tq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorParam::clear_has_max_tq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorParam::clear_max_tq() {
  max_tq_ = 0;
  clear_has_max_tq();
}
inline double M3ActuatorParam::max_tq() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.max_tq)
  return max_tq_;
}
inline void M3ActuatorParam::set_max_tq(double value) {
  set_has_max_tq();
  max_tq_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.max_tq)
}

// optional double min_tq = 2;
inline bool M3ActuatorParam::has_min_tq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorParam::set_has_min_tq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorParam::clear_has_min_tq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorParam::clear_min_tq() {
  min_tq_ = 0;
  clear_has_min_tq();
}
inline double M3ActuatorParam::min_tq() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.min_tq)
  return min_tq_;
}
inline void M3ActuatorParam::set_min_tq(double value) {
  set_has_min_tq();
  min_tq_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.min_tq)
}

// optional double max_i = 3;
inline bool M3ActuatorParam::has_max_i() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorParam::set_has_max_i() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorParam::clear_has_max_i() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorParam::clear_max_i() {
  max_i_ = 0;
  clear_has_max_i();
}
inline double M3ActuatorParam::max_i() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.max_i)
  return max_i_;
}
inline void M3ActuatorParam::set_max_i(double value) {
  set_has_max_i();
  max_i_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.max_i)
}

// optional double max_amp_current = 4;
inline bool M3ActuatorParam::has_max_amp_current() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3ActuatorParam::set_has_max_amp_current() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3ActuatorParam::clear_has_max_amp_current() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3ActuatorParam::clear_max_amp_current() {
  max_amp_current_ = 0;
  clear_has_max_amp_current();
}
inline double M3ActuatorParam::max_amp_current() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.max_amp_current)
  return max_amp_current_;
}
inline void M3ActuatorParam::set_max_amp_current(double value) {
  set_has_max_amp_current();
  max_amp_current_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.max_amp_current)
}

// optional double max_overload_time = 5;
inline bool M3ActuatorParam::has_max_overload_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void M3ActuatorParam::set_has_max_overload_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void M3ActuatorParam::clear_has_max_overload_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void M3ActuatorParam::clear_max_overload_time() {
  max_overload_time_ = 0;
  clear_has_max_overload_time();
}
inline double M3ActuatorParam::max_overload_time() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.max_overload_time)
  return max_overload_time_;
}
inline void M3ActuatorParam::set_max_overload_time(double value) {
  set_has_max_overload_time();
  max_overload_time_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.max_overload_time)
}

// optional double max_amp_temp = 6;
inline bool M3ActuatorParam::has_max_amp_temp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void M3ActuatorParam::set_has_max_amp_temp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void M3ActuatorParam::clear_has_max_amp_temp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void M3ActuatorParam::clear_max_amp_temp() {
  max_amp_temp_ = 0;
  clear_has_max_amp_temp();
}
inline double M3ActuatorParam::max_amp_temp() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.max_amp_temp)
  return max_amp_temp_;
}
inline void M3ActuatorParam::set_max_amp_temp(double value) {
  set_has_max_amp_temp();
  max_amp_temp_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorParam.max_amp_temp)
}

// optional .M3ActuatorParamPID pid_torque = 7;
inline bool M3ActuatorParam::has_pid_torque() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void M3ActuatorParam::set_has_pid_torque() {
  _has_bits_[0] |= 0x00000100u;
}
inline void M3ActuatorParam::clear_has_pid_torque() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void M3ActuatorParam::clear_pid_torque() {
  if (pid_torque_ != NULL) pid_torque_->::M3ActuatorParamPID::Clear();
  clear_has_pid_torque();
}
inline const ::M3ActuatorParamPID& M3ActuatorParam::pid_torque() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.pid_torque)
  return pid_torque_ != NULL ? *pid_torque_ : *default_instance_->pid_torque_;
}
inline ::M3ActuatorParamPID* M3ActuatorParam::mutable_pid_torque() {
  set_has_pid_torque();
  if (pid_torque_ == NULL) pid_torque_ = new ::M3ActuatorParamPID;
  // @@protoc_insertion_point(field_mutable:M3ActuatorParam.pid_torque)
  return pid_torque_;
}
inline ::M3ActuatorParamPID* M3ActuatorParam::release_pid_torque() {
  clear_has_pid_torque();
  ::M3ActuatorParamPID* temp = pid_torque_;
  pid_torque_ = NULL;
  return temp;
}
inline void M3ActuatorParam::set_allocated_pid_torque(::M3ActuatorParamPID* pid_torque) {
  delete pid_torque_;
  pid_torque_ = pid_torque;
  if (pid_torque) {
    set_has_pid_torque();
  } else {
    clear_has_pid_torque();
  }
  // @@protoc_insertion_point(field_set_allocated:M3ActuatorParam.pid_torque)
}

// optional .M3ActuatorParamAngleDf angle_df = 8;
inline bool M3ActuatorParam::has_angle_df() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void M3ActuatorParam::set_has_angle_df() {
  _has_bits_[0] |= 0x00000200u;
}
inline void M3ActuatorParam::clear_has_angle_df() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void M3ActuatorParam::clear_angle_df() {
  if (angle_df_ != NULL) angle_df_->::M3ActuatorParamAngleDf::Clear();
  clear_has_angle_df();
}
inline const ::M3ActuatorParamAngleDf& M3ActuatorParam::angle_df() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.angle_df)
  return angle_df_ != NULL ? *angle_df_ : *default_instance_->angle_df_;
}
inline ::M3ActuatorParamAngleDf* M3ActuatorParam::mutable_angle_df() {
  set_has_angle_df();
  if (angle_df_ == NULL) angle_df_ = new ::M3ActuatorParamAngleDf;
  // @@protoc_insertion_point(field_mutable:M3ActuatorParam.angle_df)
  return angle_df_;
}
inline ::M3ActuatorParamAngleDf* M3ActuatorParam::release_angle_df() {
  clear_has_angle_df();
  ::M3ActuatorParamAngleDf* temp = angle_df_;
  angle_df_ = NULL;
  return temp;
}
inline void M3ActuatorParam::set_allocated_angle_df(::M3ActuatorParamAngleDf* angle_df) {
  delete angle_df_;
  angle_df_ = angle_df;
  if (angle_df) {
    set_has_angle_df();
  } else {
    clear_has_angle_df();
  }
  // @@protoc_insertion_point(field_set_allocated:M3ActuatorParam.angle_df)
}

// optional .M3ActuatorParamFilter torquedot_df = 9;
inline bool M3ActuatorParam::has_torquedot_df() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void M3ActuatorParam::set_has_torquedot_df() {
  _has_bits_[0] |= 0x00000400u;
}
inline void M3ActuatorParam::clear_has_torquedot_df() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void M3ActuatorParam::clear_torquedot_df() {
  if (torquedot_df_ != NULL) torquedot_df_->::M3ActuatorParamFilter::Clear();
  clear_has_torquedot_df();
}
inline const ::M3ActuatorParamFilter& M3ActuatorParam::torquedot_df() const {
  // @@protoc_insertion_point(field_get:M3ActuatorParam.torquedot_df)
  return torquedot_df_ != NULL ? *torquedot_df_ : *default_instance_->torquedot_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParam::mutable_torquedot_df() {
  set_has_torquedot_df();
  if (torquedot_df_ == NULL) torquedot_df_ = new ::M3ActuatorParamFilter;
  // @@protoc_insertion_point(field_mutable:M3ActuatorParam.torquedot_df)
  return torquedot_df_;
}
inline ::M3ActuatorParamFilter* M3ActuatorParam::release_torquedot_df() {
  clear_has_torquedot_df();
  ::M3ActuatorParamFilter* temp = torquedot_df_;
  torquedot_df_ = NULL;
  return temp;
}
inline void M3ActuatorParam::set_allocated_torquedot_df(::M3ActuatorParamFilter* torquedot_df) {
  delete torquedot_df_;
  torquedot_df_ = torquedot_df;
  if (torquedot_df) {
    set_has_torquedot_df();
  } else {
    clear_has_torquedot_df();
  }
  // @@protoc_insertion_point(field_set_allocated:M3ActuatorParam.torquedot_df)
}

// -------------------------------------------------------------------

// M3ActuatorCommand

// optional int32 pwm_desired = 1;
inline bool M3ActuatorCommand::has_pwm_desired() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorCommand::set_has_pwm_desired() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorCommand::clear_has_pwm_desired() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorCommand::clear_pwm_desired() {
  pwm_desired_ = 0;
  clear_has_pwm_desired();
}
inline ::google::protobuf::int32 M3ActuatorCommand::pwm_desired() const {
  // @@protoc_insertion_point(field_get:M3ActuatorCommand.pwm_desired)
  return pwm_desired_;
}
inline void M3ActuatorCommand::set_pwm_desired(::google::protobuf::int32 value) {
  set_has_pwm_desired();
  pwm_desired_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorCommand.pwm_desired)
}

// optional double tq_desired = 2;
inline bool M3ActuatorCommand::has_tq_desired() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorCommand::set_has_tq_desired() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorCommand::clear_has_tq_desired() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorCommand::clear_tq_desired() {
  tq_desired_ = 0;
  clear_has_tq_desired();
}
inline double M3ActuatorCommand::tq_desired() const {
  // @@protoc_insertion_point(field_get:M3ActuatorCommand.tq_desired)
  return tq_desired_;
}
inline void M3ActuatorCommand::set_tq_desired(double value) {
  set_has_tq_desired();
  tq_desired_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorCommand.tq_desired)
}

// optional double i_desired = 3;
inline bool M3ActuatorCommand::has_i_desired() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorCommand::set_has_i_desired() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorCommand::clear_has_i_desired() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorCommand::clear_i_desired() {
  i_desired_ = 0;
  clear_has_i_desired();
}
inline double M3ActuatorCommand::i_desired() const {
  // @@protoc_insertion_point(field_get:M3ActuatorCommand.i_desired)
  return i_desired_;
}
inline void M3ActuatorCommand::set_i_desired(double value) {
  set_has_i_desired();
  i_desired_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorCommand.i_desired)
}

// optional .ACTUATOR_MODE ctrl_mode = 4;
inline bool M3ActuatorCommand::has_ctrl_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorCommand::set_has_ctrl_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorCommand::clear_has_ctrl_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorCommand::clear_ctrl_mode() {
  ctrl_mode_ = 0;
  clear_has_ctrl_mode();
}
inline ::ACTUATOR_MODE M3ActuatorCommand::ctrl_mode() const {
  // @@protoc_insertion_point(field_get:M3ActuatorCommand.ctrl_mode)
  return static_cast< ::ACTUATOR_MODE >(ctrl_mode_);
}
inline void M3ActuatorCommand::set_ctrl_mode(::ACTUATOR_MODE value) {
  assert(::ACTUATOR_MODE_IsValid(value));
  set_has_ctrl_mode();
  ctrl_mode_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorCommand.ctrl_mode)
}

// optional bool brake_off = 5;
inline bool M3ActuatorCommand::has_brake_off() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorCommand::set_has_brake_off() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorCommand::clear_has_brake_off() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorCommand::clear_brake_off() {
  brake_off_ = false;
  clear_has_brake_off();
}
inline bool M3ActuatorCommand::brake_off() const {
  // @@protoc_insertion_point(field_get:M3ActuatorCommand.brake_off)
  return brake_off_;
}
inline void M3ActuatorCommand::set_brake_off(bool value) {
  set_has_brake_off();
  brake_off_ = value;
  // @@protoc_insertion_point(field_set:M3ActuatorCommand.brake_off)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ACTUATOR_MODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ACTUATOR_MODE>() {
  return ::ACTUATOR_MODE_descriptor();
}
template <> struct is_proto_enum< ::ACTUATOR_INPUT> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ACTUATOR_INPUT>() {
  return ::ACTUATOR_INPUT_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_actuator_2eproto__INCLUDED
